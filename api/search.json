[{"id":"9575e4b650941f02c5b9a1d623012ff0","title":"MySql","content":"MySql创建，删除，查询数据库与表等基础语句(指令)创建数据库#演示数据库的操作\n#启动和关闭数据库\nnet START mysql\n\nnet STOP mysql\n\n#创建一个名为lby_db01的数据库。\n#使用指令创建数据库\nCREATE DATABASE lby_db01\n\n#删除数据库\nDROP DATABASE lby_db01\n\n#创建一个使用utf8字符集的lby_db02数据库\nCREATE DATABASE lby_db02 CHARACTER SET utf8\n\n#创建一个使用utf8字符集，并带校对规则的lby_db03数据库\nCREATE DATABASE lby_db03 CHARACTER SET utf8 COLLATE utf8_bin\n\n#校对规则 utf8_bin 区分大小写 默认utf8_general_ci 不区分大小写\n#下面是一条查询的sql，select 表示查询     *  表示所有字段      FROM表示从哪个表#WHERE 表示从哪个字段 \t\tNAME &#x3D; ‘tom’ 表示查询名字是tom\nSELECT * FROM t1 WHERE NAME &#x3D; &#39;tom&#39;\n\n查询数据库#查看当前数据库服务器中的所有数据库\nSHOW DATABASES\n\n#查看前面创建的lby_db01数据库的定义信息\nSHOW CREATE DATABASE lby_db01\n\n#在创建数据库，表的时候，为了规避关键字，可以使用反引号解决\nCREATE DATABASE &#96;create&#96;\n\n#删除上面创建的create数据库\nDROP DATABASE &#96;create&#96;\n\n备份恢复数据库#备份，要在Dos下执行mysqldump指令其实在mysql安装目录下\\bin#这个备份的文件，就是对应的sql语句\nmysqldump -u root -p -B lby_db02 lby_db03 &gt; C:\\\\bak.sql\n\nDROP DATABASE lby_db03;\n\n#恢复数据库(注意：进入Mysql命令行执行)\nsource C:\\\\bak.sql\n\n#第二个恢复方法，直接将bak.sql的内容放到查询编辑器中，执行就可以了\n#备份数据库的表\nmysqldump -u root -p lby_db02 t1 t2 &gt;C:\\\\bak02.sql\n\n创建表#指令创建表\nCREATE TABLE &#96;user&#96; (\n\tid INT,\n\t&#96;name&#96; VARCHAR(255),\n\t&#96;password&#96; VARCHAR(255),\n\tbirthday DATE)\n\tCHARACTER SET utf8 COLLATE utf8_bin ENGINE INNODB;\n\n简单说明：utf8表示这个表的字符集，utf8_bin表示这个表的校对规则，innodb表示这个表的引擎\ncharacter set：指定表的字符集，若没有指定，则默认为所在数据库的字符集\ncollate：指定表的校对规则，若没有指定，则默认为所在数据库的校对规则\nengine：指定表的引擎\n练习：\nCREATE TABLE t15 (\n\tid INT,\n\t&#96;name&#96; CHAR(32),\n\tsex CHAR(32),\n\tbirthday DATE,\n\tentry_date DATETIME,\n\tjob CHAR(32),\n\tSalary DOUBLE,\n\tRESUME TEXT) CHARSET utf8 COLLATE utf8_bin ENGINE INNODB;\nSELECT * FROM t15;\n\n– 添加一条\nINSERT INTO t15 VALUES(100,&#39;李白&#39;,&#39;2000-11-18&#39;,&#39;2018-11-18 11:11:11&#39;,\n&#39;写诗的&#39;,10000,&#39;皇上叫我写诗&#39;,&#39;&#39;);\n\n修改表#添加列– ALTER TABLE tablename– ADD\t(column datatype [DEFAULT exper]–\t[, column datatype]…);– 员工表t15的基础上增加一个image列，char类型(要求加在resume后面)\nALTER TABLE t15\nADD\timage CHAR(32) NOT NULL DEFAULT &#39;&#39; AFTER RESUME;\n\nDESC employee\n\n – 显示表结构，可以查看表的所有列\n#修改列– 修改job列，使其长度为60\nALTER TABLE t15\n\tMODIFY job VARCHAR(60) NOT NULL DEFAULT &#39; &#39;\n\n– 删除sec列\nALTER TABLE t15\n\tDROP sex\n\n– 表名改为employee\nRENAME TABLE t15 TO employee\n\n– 修改表的字符集为utf8\nALTER TABLE employee CHARACTER SET utf8\n\n– 列名name修改为user_name\nALTER TABLE employee CHANGE NAME user_name VARCHAR(32) NOT NULL DEFAULT &#39; &#39;\n\nSELECT * FROM employee;\n\n\n\n列类型常用数据类型\n整型#演示整数#说明：表的字符集，校验规则，存储引擎，使用默认#1.如果没有指定unsigned，则TINYINT就是有符号的(-128~127)，如果没有符号(0-255)#2.如果指定unsigned，则TINYINT就是无符号0-255\nCREATE TABLE t3 (\n\tid TINYINT);\nCREATE TABLE t4 (\n\tid TINYINT UNSIGNED);\n\nINSERT INTO t3 VALUES(128);#这是非常简单的添加语句，添加失败，超过tinyint范围，因为这是带符号的\n\nSELECT * FROM t3\nINSERT INTO t4 VALUES(255);#添加成功\nSELECT * FROM t4\n\nbit#演示bit类型使用#说明#1.bit(m) m在1-64#2.添加数据 范围 按照你给的位数来确定，比如m&#x3D;8表示一个字节 0~255#3.显示按照bit#4.查询时，仍然可以按照数来查询\nCREATE TABLE t5 (num BIT(8));\nINSERT INTO t5 VALUES(255);\nSELECT * FROM t5\nSELECT * FROM t5 WHERE num &#x3D; 1;\n\n小数型#演示decimal类型，float，double使用（一般使用double或者decimal，因为其精度更高）#创建表\nCREATE TABLE t6 (\n\tnum1 FLOAT,\n\tnum2 DOUBLE,\n\tnum3 DECIMAL(30,20));\n\n#decimal(m,n)如果没有给m，n赋值，那么会默认m为10，n为0#添加数据\nINSERT INTO t6 VALUES(88.12345678912345,88.12345678912345,88.12345678912345);\n\nSELECT * FROM t6;\n\n#decimal可以存放很大的数\nCREATE TABLE t7 (\n\tnum DECIMAL(65));\nINSERT INTO t7 VALUES(899999999999999999999999999999999999999999999999999999999999999);\nSELECT * FROM t7;\n\nCREATE TABLE t8 (\n\tnum BIGINT UNSIGNED);\nINSERT INTO t8 VALUES(899999999999999999999999999999999999999999999999999999999999999);\nSELECT * FROM t8;\n\n\n字符串#演示字符串类型使用char varchar#注释的快捷键 shift+ctrl+c，取消注释 shift+ctrl+r– CHAR(size)– 固定长度字符串 最大255字符– VARCHAR(size)      0~65535(字节，而不是字符)– 可变长度字符串 最大65532字节   【utf8编码最大21844字符 1-3个字节用于记录大小】– 如果表的编码是 utf8 varchar(size) size&#x3D;(65535-3) &#x2F; 3 &#x3D; 21844– 如果表的编码是 gbk varchar(size) size&#x3D;(65535-3) &#x2F; 2 &#x3D; 32766\nCREATE TABLE t9 (\n\t&#96;name&#96; CHAR(255));\nCREATE TABLE t10 (\n\t&#96;name&#96; VARCHAR(32766) CHARACTER SET gbk);\n\n#演示字符串类型的使用细节#1.char(4) 和 varchar(4) 这个4表示的是字符，而不是字节，不区分字符是汉字还是字母#2.char(4)是定长(固定的大小)，就是说，即使你插入’aa’，也会占用分配的4个字节的空间#3.varchar(4)是变长(变化的大小)，就是说，如果你插入了’aa’，实际占用空间大小并不是4个字符– 而是按照实际占用空间来分配– varchar本身还需要1-3个字节来记录存放内容长度– L(实际数据大小)+(1-3)字节\nCREATE TABLE t11 (\n\t&#96;name&#96; CHAR(4));\nINSERT INTO t11 VALUES(&#39;abcd&#39;);\n\nINSERT INTO t11 VALUES(&#39;白居易号&#39;);\n\nSELECT * FROM t11;\n\nCREATE TABLE t12 (\n\t&#96;name&#96; VARCHAR(4));\nINSERT INTO t12 VALUES(&#39;abcd&#39;);\n\nINSERT INTO t12 VALUES(&#39;白居易号&#39;);\n\nINSERT INTO t12 VALUES(&#39;ab李白&#39;);\n\nSELECT * FROM t12;\n\n#4.什么时候使用char，什么时候使用varchar– 如果数据定长，推荐使用char，比如md5的密码，邮编，手机号，身份证号码等.char(32)– 如果一个字段的长度是不确定，我们使用varchar，比如留言，文章– 查询速度：char&gt;varchar\n#5.在存放文本时，也可以使用Text数据类型– 可以将Text列视为VARCHAR列，注意Text不能有默认值，大小0-2^16字节– 如果希望存放更多字符，可以选择– MEDIUMTEXT 0-2^24 或者 LONGTEXT 0~2^32\nCREATE TABLE t13 (content TEXT, content2 MEDIUMTEXT, content3 LONGTEXT);\nINSERT INTO t13 VALUES(&#39;李白是诗神&#39;,&#39;白居易是诗人&#39;,&#39;杜甫是散人~~&#39;);\nSELECT * FROM t13;\n\n日期类#演示时间相关的类型#创建一张表，date，datetime，timestamp\nCREATE TABLE t14 (\n\tbirthday DATE, -- 生日\n\tjob_time DATETIME, -- 记录年月日 时分秒\n\tlogin_time TIMESTAMP\n\t NOT NULL DEFAULT CURRENT_TIMESTAMP \n\t ON UPDATE CURRENT_TIMESTAMP); \n\n– 登录时间，如果希望login_time列自动更新，需要配置\nSELECT * FROM t14;\n\tINSERT INTO t14(birthday,job_time)\n\tVALUES(&#39;2022-11-18&#39;,&#39;2022-11-18 20:41:10&#39;);\n\n– 如果我们更新了t14表的某条记录，login_time列会自动的以当前时间进行更新\nCRUD语句insert#练习insert语句– 创建一张商品表goods (id int , goods_name , varchar(10) , price double);– 添加两条记录\nCREATE TABLE &#96;goods&#96; (\n\tid INT,\n\tgoods_name VARCHAR(10),\n\tprice DOUBLE);\n\n– 添加数据\nINSERT INTO &#96;goods&#96; (id,goods_name,price)\n\tVALUES(10,&#39;华为手机&#39;,5000);\nINSERT INTO &#96;goods&#96; (id,goods_name,price)\n\tVALUES(20,&#39;苹果手机&#39;,9000);\nSELECT * FROM &#96;goods&#96;;\n\nCREATE TABLE &#96;goods2&#96; (\n\tid INT,\n\tgoods_name VARCHAR(10),\n\tprice DOUBLE NOT NULL DEFAULT 100);\n\n#追加练习– 使用insert语句向表employee中插入2个员工的信息\nINSERT INTO employee (id,user_name,birthday,entry_date,job,Salary,&#96;resume&#96;)\n\tVALUES(101,&#39;杜甫&#39;,&#39;1998-11-21&#39;,&#39;1998-11-28 21:00:00&#39;,&#39;写诗的&#39;,6000,&#39;为百姓写诗&#39;);\nINSERT INTO employee (id,user_name,birthday,entry_date,job,Salary,&#96;resume&#96;)\n\tVALUES(102,&#39;白居易&#39;,&#39;2016-11-21&#39;,&#39;2016-11-28 21:00:00&#39;,&#39;写诗的&#39;,6000,&#39;为历史写诗&#39;);\nSELECT * FROM employee;\n\n#说明insert语句的细节– 1.插入的数据应与字段的数据类型相同–\t比如把’abc’添加到int类型会错误\nINSERT INTO &#96;goods&#96; (id,goods_name,price)**\n\tVALUES(&#39;abc&#39;,&#39;小米手机&#39;,4000);#Incorrect integer value\nINSERT INTO &#96;goods&#96; (id,goods_name,price)**\n\tVALUES(&#39;30&#39;,&#39;小米手机&#39;,4000);#success,底层会尝试转换\n\n– 2.数据的长度应在列的规定范围内，例如：不能将一个长度为80的字符串加入到长度为40的列中\nINSERT INTO &#96;goods&#96; (id,goods_name,price)\n\tVALUES(40,&#39;vivovivovivovivovivovivo手机&#39;,3000);#Data too long for column\n\n– 3.在values中列出的数据位置必须与被加入的列的排序位置相对应\nINSERT INTO &#96;goods&#96; (id,goods_name,price)\n\tVALUES(&#39;vivo手机&#39;,40,3000);#Incorrect integer value\nINSERT INTO &#96;goods&#96; (goods_name,id,price)\n\tVALUES(&#39;vivo手机&#39;,40,3000);#success\n\n– 4.字符和日期型数据应包含在单引号中\nINSERT INTO &#96;goods&#96; (id,goods_name,price)\n\tVALUES(40,vivo手机,3000);#Unknown column 应该&#39;vivo手机&#39;\n\n– 5.**列可以插入空值[前提是该字段允许为空]**，insert into table_name values(null)\nINSERT INTO &#96;goods&#96; (id,goods_name,price)\n\tVALUES(50,&#39;oppo手机&#39;,NULL);#success 因为我们创建表的时候没设置不为空 即(not null)\n\n– 6.insert into table_name (列名…) values (),(),()  形式添加多条记录\nINSERT INTO &#96;goods&#96; (id,goods_name,price)\n\tVALUES(60,&#39;三星手机&#39;,6000),(60,&#39;海尔手机&#39;,7000);#success\n\n– 7.如果是给表中的所有字段添加数据，可以不写前面的字段名称\nINSERT INTO &#96;goods&#96; \n\tVALUES(70,&#39;IBM手机&#39;,5000);#success\n\n– 8.默认值的使用，当不给某个字段值时，如果有默认值就会添加默认值，否则报错–\t如果某个列，没有指定not null，那么添加数据时，没有给定值，则会默认给null\nINSERT INTO &#96;goods2&#96; (id,goods_name)\n\tVALUES(80,&#39;格力手机&#39;);#success,并且自动给price添加默认值100\nSELECT * FROM &#96;goods2&#96;;\n\nupdate#演示update语句– 要求：在上面创建的employee表中修改表中的记录– 1.将所有员工薪水修改为5000元.如果没有带where这个条件，会修改所有的记录，因此使用要小心\nUPDATE employee SET Salary &#x3D; 5000\n\n– 2.将姓名为李白的员工薪水修改为8000元\nUPDATE employee \n\tSET salary &#x3D; 3000 \n\tWHERE user_name &#x3D; &#39;李白&#39;;\n\n\n– 3.将姓名为杜甫的员工在原有薪水基础上增加2000元\nUPDATE employee\n\tSET salary &#x3D; salary + 2000\n\tWHERE user_name &#x3D; &#39;杜甫&#39;;\n\t\nSELECT * FROM employee;\n\n#update语句使用细节– 1.update语法可以用新值更新原有表行中的各列– 2.set子句指示要修改哪些列和要给予哪些值– 3.where子句指定应更新哪些行。如没有where子句，则更新所有的行(记录)，因此使用时要小心– 4.如果需要修改多个字段，可以通过set 字段1&#x3D;值1，字段2&#x3D;值2…..\ndelete#delete语句演示– 删除表中名称为’杜甫’的记录\nDELETE FROM employee\n\tWHERE user_name &#x3D; &#39;杜甫&#39;;\n\n– 删除表中所有记录–\t如不需要where子句，将删除表中所有数据\nDELETE FROM employee;\n\n#delete语句使用细节– delete语句不能删除某一列的值(可使用update 设为null或者’’)\nUPDATE employee SET job &#x3D; &#39;&#39; WHERE user_name&#x3D;&#39;杜甫&#39;;\n\n– 使用delete语句仅删除记录，不删除表本身。如要删除表，使用drop table语句。– \tdrop table 表名;\nDROP TABLE employee;\nSELECT * FROM employee;\n\nselect1.0– select 语句【重点 难点】– 格式:– SELECT [distinct] * {column1,column2,column3..}– \t\tFROM table_name;\nCREATE TABLE student (\n\tid INT NOT NULL DEFAULT 1,\n\t&#96;name&#96; VARCHAR(20) NOT NULL DEFAULT &#39;&#39;,\n\tchinese FLOAT NOT NULL DEFAULT 0.0,\n\tenglish FLOAT NOT NULL DEFAULT 0.0,\n\tmath FLOAT NOT NULL DEFAULT 0.0);\n\nINSERT INTO student \n\tVALUES(1,&#39;李白&#39;,100,90,80),(2,&#39;杜甫&#39;,100,90,90),(3,&#39;白居易&#39;,95,80,80),(4,&#39;王维&#39;,95,80,80),\n\t(5,&#39;赵云&#39;,82,84,67),(6,&#39;关羽&#39;,88,98,90),(7,&#39;张飞&#39;,67,98,56),(8,&#39;李世民&#39;,100,90,95);\n\t\nSELECT * FROM student;\n\n– 查询表中所有学生的信息\nSELECT * FROM student;\n\n– 查询表中所有学生的姓名和对应的英语成绩\nSELECT &#96;name&#96;,english FROM student;\n\n– 过滤表中重复数据 distinct\nSELECT DISTINCT english FROM student;\n\n– 要查询的记录，每个字段都相同，才会去重\nSELECT DISTINCT &#96;name&#96;,english FROM student;\n\n2.0#select语句的使用– 使用表达式对查询的列进行运算– SELECT * |{column1|expression,column2|expression…}– \t\tFROM table_name;\n– 在select语句中可使用as语句– SELECT column_name as 别名 from 表名;\n– 统计每个学生的总分\nSELECT &#96;name&#96;,(chinese+english+math) FROM student;\n\n– 在所有学生总分加10分的情况\nSELECT &#96;name&#96;,(chinese+english+math+10) FROM student;\n\n– 使用别名表示学生分数\nSELECT &#96;name&#96; AS &#39;名字&#39;,(chinese+english+math+10) AS total_score FROM student;\n\n3.0#select语句– 查询姓名为赵云的学生成绩\nSELECT * FROM student WHERE &#96;name&#96;&#x3D;&#39;赵云&#39;;\n\n– 查询英语成绩大于90分的同学\nSELECT * FROM student WHERE english&gt;90;\n\n– 查询总分大于200分的所有同学\nSELECT * FROM student WHERE (chinese+english+math)&gt;200;\n\n– 查询math大于60并且(and)id大于4的学生成绩\nSELECT * FROM student WHERE math&gt;60 AND id&gt;4;\n\n– 查询英语成绩大于语文成绩的同学\nSELECT * FROM student WHERE english&gt;chinese;\n\n– 查询总分大于200分并且数学成绩小于语文成绩的姓李的学生– 李%表示名字以李开头的就可以\nSELECT * FROM student WHERE\n\t(chinese+math+english)&gt;200 AND math&lt;chinese\n\t AND &#96;name&#96; LIKE &#39;李%&#39;;\n\n\n– 查询英语成绩在80-90之间的同学\nSELECT * FROM student WHERE english&gt;&#x3D;80 AND english&lt;&#x3D;90;\n\n– between..and…是一个闭区间\nSELECT * FROM student WHERE english BETWEEN 80 AND 90;\n\n– 查询数学分数为89，90，91的同学\nSELECT * FROM student WHERE math BETWEEN 89 AND 91;\nSELECT * FROM student WHERE math&#x3D;89 OR math&#x3D;90 OR math&#x3D;91;\nSELECT * FROM student WHERE math IN(89,90,91);\n\n– 查询所有姓李的学生成绩(%表示任意多个字符)\nSELECT * FROM student WHERE &#96;name&#96; LIKE &#39;李%&#39;;\n\n– 查询数学分&gt;80，语文成绩&gt;80的同学\nSELECT * FROM student WHERE math&gt;80 AND chinese&gt;80;\n\n函数统计函数#演示mysql统计函数的使用– count– 统计一个班级****共有多少学生\nSELECT COUNT(*) FROM student;\n\n– 统计数学成绩大于90的有多少个\nSELECT COUNT(*) FROM student WHERE math&gt;90;\n\n– 统计总分大于250的人数有多少\nSELECT COUNT(*) FROM student WHERE (math+chinese+english)&gt;250;\n\n– count(*)和count(列)的区别– 解释：count(*)返回满足条件的记录的行数– count(列)：统计满足条件的某列有多少个，但是会排除为null\nCREATE TABLE t15 (\n\t&#96;name&#96; VARCHAR(20));\nINSERT INTO t15 VALUES(&#39;tom&#39;);\nINSERT INTO t15 VALUES(&#39;jack&#39;);\nINSERT INTO t15 VALUES(&#39;mary&#39;);\nINSERT INTO t15 VALUES(NULL);\n\nSELECT * FROM t15;\nSELECT COUNT(*) FROM t15;-- 4\nSELECT COUNT(&#96;name&#96;) FROM t15;-- 3\n\n– sum– 统计一个班级数学总成绩\nSELECT SUM(math) FROM student;\n\n– 统计一个班级语文，英语，数学各科的总成绩\nSELECT SUM(math),SUM(english),SUM(chinese) FROM student;\n\n– 统计一个班级语文，英语，数学的成绩总和\nSELECT SUM(math+english+chinese) FROM student;\n\n– 统计一个班级语文成绩平均分\nSELECT SUM(chinese)&#x2F;COUNT(*) FROM student;\n\n– avg– 求一个班级数学平均分\nSELECT AVG(math) FROM student;\n\n– 求一个班级总分平均分\nSELECT AVG(math+english+chinese) FROM student;\n\n– Max&#x2F;min– 求班级最高分和最低分\nSELECT MAX(math+chinese+english) FROM student;\nSELECT MIN(math+chinese+english) FROM student;\n\n分组函数#演示group by的使用\nCREATE TABLE dept(&#x2F;*部门表*&#x2F;\ndeptno MEDIUMINT UNSIGNED NOT NULL DEFAULT 0,\ndname VARCHAR(20)NOT NULL DEFAULT &#39;&#39; &#39;&#39;,\n1oc VARCHAR(13)NOT NULL DEFAULT &#39;&#39; &#39;&#39;);\nINSERT INTO dept VALUES(10,&#39;ACCOUNTING&#39;,&#39;NEW YORK&#39;),(20,&#39;RESEARCH&#39;,&#39;DALLAS&#39;),(30,&#39;SALES&#39;,&#39;CHICAGO&#39;),(40,&#39;OPERATIONS&#39;,&#39;BOSTON&#39;);\nSELECT * FROM dept;\n\n#创建表EMP雇员\nDROP TABLE emp;\nCREATE TABLE emp\n(empno MEDIUMINT UNSIGNED NOT NULL DEFAULT 0,&#x2F;*编号*&#x2F;\nename VARCHAR(20)NOT NULL DEFAULT &#39;&#39; &#39;&#39;,&#x2F;*名字*&#x2F;\njob VARCHAR(9)NOT NULL DEFAULT &#39;&#39; &#39;&#39;,&#x2F;*工作*&#x2F;\nmgr MEDIUMINT UNSIGNED,&#x2F;*上级编号*&#x2F;\nhiredate DATE NOT NULL,&#x2F;*入职时间*&#x2F;\nsa1 DECIMAL(7,2) NOT NULL,&#x2F;*薪水*&#x2F;\ncomm DECIMAL(7,2),&#x2F;*红利*&#x2F;\ndeptno MEDIUMINT UNSIGNED NOT NULL DEFAULT 0&#x2F;*部门编号*&#x2F;);\n\n– 添加测试数据\nINSERT INTO emp VALUES(7369,&#39;SMITH&#39;,&#39;CLERK&#39;,7902,&#39;1990-12-17&#39;,800.00,NULL,20),\n(7499,&#39;ALLEN&#39;,&#39;SALESMAN&#39;,7698,&#39;1991-2-20&#39;,1600.00,300.00,30),\n(7521,&#39;WARD&#39;,&#39;SALESMAN&#39;,7698,&#39;1991-2-22&#39;,1250.00,500.00,30),\n(7566,&#39;J0NES&#39;,&#39;MANAGER&#39;,7839,&#39;1991-4-2&#39;,2975.00,NULL,20),\n(7654,&#39;MARTIN&#39;,&#39;SALESMAN&#39;,7698,&#39;1991-9-28&#39;,1250.00,1400.00,30),\n(7698,&#39;BLAKE&#39;,&#39;MANAGER&#39;,7839,&#39;1991-5-1&#39;,2850.00,NULL,30),\n(7782,&#39;CLARK&#39;,&#39;MANAGER&#39;,7839,&#39;1991-6-9&#39;,2450.00,NULL,10),\n(7788,&#39;SC0TT&#39;,&#39;ANALYST&#39;,7566,&#39;1997-4-19&#39;,3000.00,NULL,20),\n(7839,&#39;KING&#39;,&#39;PRESIDENT&#39;,NULL,&#39;1991-11-17&#39;,5000.00,NULL,10),\n(7844,&#39;TURNER&#39;,&#39;SALESMAN&#39;,7698,&#39;1991-9-8&#39;,1500.00,NULL,30),\n(7900,&#39;JAMES&#39;,&#39;CLERK&#39;,7698,&#39;1991-12-3&#39;,950.00,NULL,30),\n(7902,&#39;FORD&#39;,&#39;ANALYST&#39;,7566,&#39;1991-12-3&#39;,3000.00,NULL,20),\n(7934,&#39;MILLER&#39;,&#39;CLERK&#39;,7782,&#39;1992-1-23&#39;,1300.00,NULL,10);\n\nSELECT * FROM emp;\n\n#工资级别表\nCREATE TABLE salgrade(\ngrade MEDIUMINT UNSIGNED NOT NULL DEFAULT 0,&#x2F;*工资级别*&#x2F;\nlosal DECIMAL (17,2) NOT NULL,&#x2F;*该级别的最低工资*&#x2F;\nhisal DECIMAL(17,2) NOT NULL &#x2F;*该级别的最高工资*&#x2F;\n);\nINSERT INTO salgrade VALUES(1,700,1200);\nINSERT INTO salgrade VALUES(2,1201,1400);\nINSERT INTO salgrade VALUES(3,1401,2000);\nINSERT INTO salgrade VALUES(4,2001,3000);\nINSERT INTO salgrade VALUES(5,3001,9999);\n\nSELECT * FROM salgrade;\n\n– 演示group by + having– having子句用于限制分组显示结果\n– 如何显示每个部门的平均工资和最高工资– avg(sa1) max(sa1)– 按照部门来分组查询\nSELECT AVG(sa1),MAX(sa1),deptno \n\tFROM emp GROUP BY deptno;\n\n– 显示每个部门的每种岗位的平均工资和最低工资– avg(sa1) min(sa1)– 按照部门来分组查询\nSELECT AVG(sa1),MIN(sa1),deptno,job\n\tFROM emp GROUP BY deptno,job;\n\n– 显示平均工资低于2000的部门号和它的平均工资– 化繁为简，各个击破– 1.显示各个部门的平均工资和部门号– 2.在1的结果基础上，进行过滤，保留平均工资小于2000的\nSELECT AVG(sa1),deptno \n\t\tFROM emp GROUP BY deptno\n\t\tHAVING AVG(sa1)&lt;2000;\n\n– 使用别名\nSELECT AVG(sa1) AS avg_sal,deptno \n\t\tFROM emp GROUP BY deptno\n\t\tHAVING avg_sal&lt;2000;\n\n字符串函数#字符串函数使用演示    使用emp表来演示– CHARSET(str) 返回字符串字符集\nSELECT CHARSET(ename) FROM emp;\n\n– CONCAT (string2 […..]) 连接字符串,将多个列拼接成一列\nSELECT CONCAT(ename,&#39; job is &#39;,job) FROM emp;\n\n– INSTR (string,substring) 返回substring在string中出现的位置，没有返回0– dual亚元表，系统表 可以作为测试表使用\nSELECT INSTR(&#39;libai&#39;,&#39;li&#39;) FROM DUAL;\n\n– UCASE (string2) 转换为大写\nSELECT UCASE(ename) FROM emp;\n\n– LCASE (string2) 转换为小写\nSELECT LCASE(ename) FROM emp;\n\n– LEFT (string2,length) 从string2中的左边起取length个字符\nSELECT LEFT(ename,2) FROM emp;\n\n– RIGHT (string2,length) 从string2中的右边起取length个字符\nSELECT RIGHT(ename,2) FROM emp;\n\n– LENGTH (string) string长度[按照字节返回]  比如’李白’会返回6（utf8字符集）\nSELECT LENGTH(ename) FROM emp;\n\n– REPLACE (str,search_str,replace_str)– 在str中用replace_str替换search_str– 如果是manager就替换成经理\nSELECT ename ,REPLACE(job,&#39;MANAGER&#39;,&#39;经理&#39;) FROM emp;\n\n– STRCMP (string1,string2) 逐字符比较两字符串大小\nSELECT STRCMP(&#39;hsp&#39;,&#39;jsp&#39;) FROM DUAL;\n\n– SUBSTRING (str，position，[length])– 从str的position开始【从1开始计算】，取length个字符\nSELECT SUBSTRING(ename ,1,2) FROM emp;\n\n– LTRIM (string2) RTRIM (string2) 去除前端空格或者后端空格– TRIM(string) 去除前后端空格\nSELECT LTRIM(&#39;      李白是诗人&#39;) FROM DUAL;\nSELECT LTRIM(&#39;李白是诗人      &#39;) FROM DUAL;\nSELECT LTRIM(&#39;      李白是诗人       &#39;) FROM DUAL;\n\n– 以首字母小写的方式显示所有员工的姓名– 方式1\nSELECT CONCAT( LCASE(SUBSTRING(ename,1,1)) ,SUBSTRING(ename,2))\n\tFROM emp;\n\n– 方式2\nSELECT REPLACE(ename,SUBSTRING(ename,1,1),LCASE(SUBSTRING(ename,1,1)))\n\tFROM emp;\n\n– 方式3\nSELECT CONCAT( LCASE(LEFT(ename,1)) ,SUBSTRING(ename,2))\n\tFROM emp;\n\n数学函数#演示数学相关函数\n– ABS (num) 绝对值\nSELECT ABS(-10) FROM DUAL;\n\n– BIN (decimal_number) 十进制转二进制\nSELECT BIN(10) FROM DUAL;\n\n– CEILING (num2) 向上取整，得到比num2大的最小整数\nSELECT CEILING(-1.1) FROM DUAL;\n\n– CONV(num2,from_base,to_base) 进制转换– 下面的含义是  8是十进制的8，转成二进制输出\nSELECT CONV(8,10,2) FROM DUAL;\n\n– 下面的含义是  8是十六进制的8，转成二进制输出\nSELECT CONV(8,16,2) FROM DUAL;\n\n– FLOOR (num2) 向下取整，得到比num2小的最大整数\nSELECT FLOOR(-1.1) FROM DUAL;\n\n– FORMAT (num,decimal_places) 保留小数位数(四舍五入)\nSELECT FORMAT(78.1254582,2) FROM DUAL;\n\n– HEX (DecimalNumber) 转十六进制\n– LEAST (num,num2,…) 求最小值\nSELECT LEAST(0,1,-10,4) FROM DUAL;\n\n– MOD (numerator,denominator) 求余\nSELECT MOD(10,3) FROM DUAL;\n\n– RAND ([seed])  RAND([seed]) 返回随机数 其范围为0&lt;&#x3D;v&lt;&#x3D;1.0– 1.如果使用RAND()每次返回不同的随机数，在0&lt;&#x3D;v&lt;&#x3D;1.0之间– 2.如果使用RAND(seed) 返回随机数，范围0&lt;&#x3D;v&lt;&#x3D;1.0，如果seed不变，该随机数也不变了\nSELECT RAND(6) FROM DUAL;\n\n日期函数#日期时间相关函数\n– CURRENT_DATE()    当前日期\nSELECT CURRENT_DATE() FROM DUAL;\n\n– CURRENT_TIME()    当前时间\nSELECT CURRENT_TIME() FROM DUAL;\n\n– CURRENT_TIMESTAMP()    当前时间戳\nSELECT CURRENT_TIMESTAMP() FROM DUAL;\n\n– 创建测试表 信息表\nCREATE TABLE mes(\n\tid INT,\n\tcontent VARCHAR(32),\n\tsend_time DATETIME);\n\n– 添加一条记录\nINSERT INTO mes VALUES(1,&#39;北京新闻&#39;,CURRENT_TIMESTAMP());\nINSERT INTO mes VALUES(2,&#39;上海新闻&#39;,NOW());\nINSERT INTO mes VALUES(3,&#39;广州新闻&#39;,NOW());\n\nSELECT * FROM mes;\nSELECT NOW() FROM DUAL;\n\n– 应用实例– 显示所有新闻信息，发布日期只显示日期，不显示时间\nSELECT id,content,DATE(send_time) FROM mes;\n\n– 请查询在10分钟内发布的新闻\nSELECT * FROM mes WHERE DATE_ADD(send_time,INTERVAL 10 MINUTE)&gt;&#x3D;NOW();\nSELECT * FROM mes WHERE send_time&gt;&#x3D; DATE_SUB(NOW(),INTERVAL 10 MINUTE);\n\n– 请在mysql的sql语句中求出2011-11-11和1990-1-1相差多少天\nSELECT DATEDIFF(&#39;2011-11-11&#39;,&#39;1990-01-01&#39;) FROM DUAL;\n\n– 请用mysql的sql语句求出你活了多少天？【练习】 2003-09-11 出生\nSELECT DATEDIFF(NOW(),&#39;2003-09-11&#39;) FROM DUAL;\n\n– 如果你能活80岁，求出你还能活多少天? 【练习】 2003-09-11 出生– 先求出活80岁时，是什么日期– 然后在使用datediff(x,now());– INTERVAL 80 YEAR：YEAR可以是替换成年月日，时分秒\nSELECT DATEDIFF(DATE_ADD(&#39;2003-09-11&#39;,INTERVAL 80 YEAR),NOW()) FROM DUAL;\n\n– YEAR|MONTH|DAY| DATE (datetimee)：(即返回年|月|日)\nSELECT YEAR(NOW()) FROM DUAL;\nSELECT MONTH(NOW()) FROM DUAL; \nSELECT DAY(NOW()) FROM DUAL;\nSELECT MONTH(&#39;2003-11-10&#39;) FROM DUAL;\n\n– unix_timestamp()：返回的是1970-01-01 到现在的秒数\nSELECT UNIX_TIMESTAMP() FROM DUAL;\n\n– FROM_UNIXTIME()：可以把一个unix_timestamp秒数，转成指定格式的日期\nSELECT FROM_UNIXTIME(1669349758,&#39;%Y-%m-%d&#39;) FROM DUAL;\nSELECT FROM_UNIXTIME(1669349758,&#39;%Y-%m-%d %H:%i:%s&#39;) FROM DUAL;\n\n加密函数#演示加密函数和系统函数– USER()   查询用户– 可以查看登录到mysql的有哪些用户，以及登录的IP\nSELECT USER() FROM DUAL; -- 用户@IP地址\n\n– DATABASE()   查询当前使用数据库名称\nSELECT DATABASE();\n\n– MD5(str)  为字符串算出一个MD5  32位的字符串，常用(用户密码)加密– root 密码是lby-&gt;加密md5-&gt;在数据库中存放的是加密后的密码\nSELECT MD5(&#39;lby&#39;) FROM DUAL;\nSELECT LENGTH(MD5(&#39;lby&#39;)) FROM DUAL;\n\n– 演示用户表，存放密码时，是md5\nCREATE TABLE lby_user\n\t(id INT,\n\t&#96;name&#96; VARCHAR(32) NOT NULL DEFAULT &#39; &#39;,\n\tpwd CHAR(32) NOT NULL DEFAULT &#39; &#39;);\n\nINSERT INTO lby_user\n\tVALUES(100,&#39;李博扬&#39;,MD5(&#39;lby&#39;));\n\nSELECT * FROM lby_user;\nSELECT * \n\tFROM lby_user\n\tWHERE &#96;name&#96;&#x3D;&#39;李博扬&#39; AND pwd&#x3D;MD5(&#39;lby&#39;);\n\n– PASSWORD(str) –加密函数,在MYSQL数据库的用户密码就是PASSWORD加密的\nSELECT PASSWORD(&#39;lby&#39;) FROM DUAL;-- *2DE7B6C45E31629453E39499BDA8A5950CA05900\n\n\n– select * from mysql.user \\G 从原文密码str计算并返回密码字符串– 通常用于对mysql数据库的用户密码加密– mysql.user 表示数据库.表\nSELECT * FROM mysql.user;\n\n流程控制函数#演示流程控制语句– IF(expr1,expr2,expr3) 如果expr1为True，则返回expr2，否则返回expr3\nSELECT IF(TRUE,&#39;李白&#39;,&#39;杜甫&#39;) FROM DUAL;\n\n– IFNULL(expr1,expr2) 如果expr1不为NULL，则返回expr1，否则返回expr2\nSELECT IFNULL(NULL,&#39;李白&#39;) FROM DUAL;\n\n– SELECT CASE WHEN expr1 THEN expr2 WHEN expr3 THEN expr4 ELSE expr5 END;[类似多重分支]– 如果expr1为TRUE，则返回expr2，如果expr3为TRUE，返回expr4，否则返回expr5\nSELECT CASE\n\tWHEN TRUE THEN &#39;jack&#39; -- jack\n\tWHEN FALSE THEN &#39;tom&#39;\n\tELSE &#39;mary&#39; END\n\n\n– 1.查询emp表，如果comm是null，则显示0.0– 判断是否为null，要使用is null，判断不为空，使用is not null\nSELECT ename,IF(comm IS NULL,0.0,comm) FROM emp;\nSELECT ename,IFNULL(comm,0.0) FROM emp;\n\n– 2.如果emp表的job是CLERK则显示职员，如果是MANAGER则显示经理– 如果是SALESMAN则显示销售人员，其它正常显示\nSELECT ename,(SELECT CASE\n\t\tWHEN job&#x3D;&#39;clerk&#39; THEN &#39;职员&#39;\n\t\tWHEN job&#x3D;&#39;manager&#39; THEN &#39;经理&#39;\n\t\tWHEN job&#x3D;&#39;salesman&#39; THEN &#39;销售人员&#39;\n\t\tELSE  job END) job\n\tFROM emp;\n\n查询增强#查询加强– 使用where子句– 如何查找1992.1.1后入职的员工– 在mysql中，日期类型可以直接比较，需要注意格式\nSELECT * FROM emp\n\tWHERE hiredate &gt; &#39;1992-1-1&#39;;\n\n– 如何使用like操作符– %表示0到多个字符  _表示单个字符– 如何显示首字符为S的员工姓名和工资\nSELECT ename,sa1\n\tFROM emp\n\tWHERE ename LIKE &#39;S%&#39;;\n\n– 如何显示第三个字符为大写O的所有员工的姓名和工资\nSELECT ename,sa1 FROM emp\n\tWHERE ename LIKE &#39;__0%&#39;;\n\n– 如何显示没有上级的雇员的情况\nSELECT * FROM emp\n\tWHERE mgr IS NULL;\n\n– 查询表结构\nDESC emp;\n\n– 使用order by子句– 如何按照工资从低到高的顺序[升序]，显示雇员的信息\nSELECT * FROM emp\n\tORDER BY sa1;\n\n– 按照部门号升序而雇员的工资降序排列，显示雇员信息\nSELECT * FROM emp\n\tORDER BY deptno ASC,sa1 DESC;\n\n分页查询#分页查询– 按雇员的id号升序取出，每页显示3条记录，请分别显示第1页，第2页，第2页– 第1页\nSELECT * FROM emp\n\tORDER BY empno\n\tLIMIT 0,3;\n\n– 第2页\nSELECT * FROM emp\n\tORDER BY empno\n\tLIMIT 3,3;\n\n– 第3页\nSELECT * FROM emp\n\tORDER BY empno\n\tLIMIT 6,3;\n\n– 推导一个公式\nSELECT * FROM emp\n\tORDER BY empno\n\n​\tLIMIT 每页显示记录数 * (第几页—1)，每页显示记录数– 练习\nSELECT * FROM emp\n\tORDER BY empno DESC\n\tLIMIT 20,5;\n\n分组增强#增强group by的使用\nSELECT * FROM emp;\n\n– 1.显示每种岗位的雇员总数，平均工资\nSELECT COUNT(*),job,AVG(sa1) FROM emp\n\tGROUP BY job;\n\n– 2.显示雇员总数，以及获得补助的雇员数– 思路：获得补助的雇员数就是comm列为非null，就是count(),如果该列的值为null，是不会统计的\nSELECT COUNT(*),COUNT(comm) \n\tFROM emp;\n\n– 扩展要求 统计没有获得补助的雇员数\nSELECT COUNT(*),COUNT(IF(comm IS NULL,1,NULL))\n\tFROM emp;\nSELECT COUNT(*),COUNT(*)-COUNT(comm)\n\tFROM emp;\n\n– 3.显示管理者的总人数\nSELECT COUNT(DISTINCT mgr)\n\tFROM emp;\n\n– 4.显示雇员工资的最大差额\nSELECT MAX(sa1)-MIN(sa1)\n\tFROM emp;\n\n\n\n多表查询笛卡儿集#多表查询– 显示雇员名，雇员工资及所在部门的名字[笛卡儿集]&#x2F;*    分析    1.雇员名，雇员工资来自emp表    2.部门的名字来自dept表    3.需求对emp和dept查询    *&#x2F;\nSELECT * FROM emp,dept;\n\n– 在默认情况下，当两个表查询时，规则为– 1.从第一张表中，取出一行和第二张表的每一行进行组合– 2.返回结果，一共返回的记录数为第一张表的行数*第二张表的行数– 3.这样多表查询默认处理返回的结果，称为笛卡尔表– 4.解决这个多表的关键就是要写出正确的过滤条件where，需求程序员进行分析– 5.当我们需要指定显示某个表的列是，需要 表.列\nSELECT ename,sa1,dname FROM emp,dept\n\tWHERE emp.deptno&#x3D;dept.deptno;\n\nSELECT ename,sa1,emp.deptno FROM emp,dept\n\tWHERE emp.deptno&#x3D;dept.deptno;\n\n\n#注意事项：多表查询的条件不能少于表的个数-1，否则会出现笛卡儿集– 如何显示部门号为10的部门名，员工名和工资\nSELECT ename,sa1,dname,emp.deptno\n\tfrom emp,dept\n\twhere emp.deptno&#x3D;dept.deptno and emp.deptno&#x3D;10;\n\n– 显示各个员工的姓名，工资，及其工资的级别– 思路：姓名，工资来自emp–\t 工资级别来自salgrade\nselect ename,sa1,grade\n\tfrom emp,salgrade\n\twhere sa1 between losal and hisal ;\n\n自连接#多表查询的自连接– 思考：显示公司员工名字和他的上级的名字– 分析：员工名字在emp，上级的名字在emp– 员工与上级是通过emp表的mgr列关联\nSELECT worker.ename,boss.ename\n\tFROM emp worker,emp boss\n\tWHERE worker.mgr&#x3D;boss.empno;\n\n– 自连接的特点– 1.把同一张表当作两张表来使用– 2.需要给表取别名–\t格式：表名 表别名– 3.列名不明确，可以指定列的别名\n多行子查询#子查询的演示– 请思考：如何显示与SMITH同一部门的所有员工？&#x2F;*    1.先查询到SMITH的部门号    2.把上面的select语句当作一个子查询来使用*&#x2F;\nSELECT deptno\n\tFROM emp\n\tWHERE ename&#x3D;&#39;SMITH&#39;\n\n– 单行子查询\nSELECT *\n\tFROM emp\n\tWHERE deptno&#x3D;(\n\t\tSELECT deptno\n\t\tFROM emp\n\t\tWHERE ename&#x3D;&#39;SMITH&#39;\n\t\t)\n\n– 如何查询和部门号为10的工作相同的雇员的名字，岗位，工资，部门号。– 但是不包含部门号为10的雇员&#x2F;*    1.先查询到10号部门有哪些工作    2.把上面查询的结果当作子查询使用*&#x2F;\nSELECT DISTINCT job\n\tFROM emp\n\tWHERE deptno&#x3D;10;\n\nSELECT ename,job,sa1,deptno\n\tFROM emp\n\tWHERE job IN(\n\t\tSELECT DISTINCT job\n\t\tFROM emp\n\t\tWHERE deptno&#x3D;10\n\t\t) AND deptno!&#x3D;10;\n\n\n\n多列子查询#多列子查询– 请思考如何查询与smith的部门和岗位完全相同的所有雇员(并且不包含smith本人)– (字段1，字段2…..) &#x3D; (select 字段1，字段2 from……)\n– 分析：– 1.得到smith的部门号和岗位\nSELECT deptno,job\n\tFROM emp\n\tWHERE ename&#x3D;&#39;SMITH&#39;;\n\n– 2.把上面查询结果当作子查询来使用，并且使用多列子查询的语法进行匹配\nSELECT*\n\tFROM emp\n\tWHERE(deptno,job)&#x3D;(\n\t\t\tSELECT deptno,job\n\t\t\tFROM emp\n\t\t\tWHERE ename&#x3D;&#39;allen&#39;\n\t\t) AND ename&lt;&gt;&#39;allen&#39;;\n\n– &lt;&gt;表示不等于\n#子查询练习– 查找每个部门工资高于本部门平均工资的人的资料\nSELECT *\n\tFROM emp,(\n\t\tSELECT deptno,AVG(sa1) avg_sa1\n\t\tFROM emp\n\t\tGROUP BY deptno\n\t)temp\n\tWHERE emp.deptno&#x3D;temp.deptno AND emp.sa1&gt;temp.avg_sa1\n\n– 查找每个部门工资最高的人的详细资料\nSELECT *\n\tFROM emp,(\n\t\tSELECT deptno,MAX(sa1) max_sa1\n\t\tFROM emp\n\t\tGROUP BY deptno\n\t)temp\n\tWHERE emp.deptno&#x3D;temp.deptno AND emp.sa1&#x3D;temp.max_sa1\n\n– 查询每个部门的信息(包括：部门号，编号，地址)和人员数量– 分析：– 1.部门名,编号,地址来自dept表– 2.各个部门的人员数量-》构建一个临时表\nSELECT COUNT(*),deptno\n\tFROM emp\n\tGROUP BY deptno;\t\n\nSELECT dname,dept.deptno,1oc ,per_num\n\tFROM dept,(\n\t\tSELECT COUNT(*) per_num,deptno\n\t\tFROM emp\n\t\tGROUP BY deptno\n\t)temp\n\tWHERE temp.deptno&#x3D;dept.deptno\n\n– 还有一种写法,表.*表示将该表所有列都显示出来，可以简化sql语句– 在多表查询中，当多个表的列不重复时，才可以直接写列名\nSELECT temp.*,dname,1oc\n\tFROM dept,(\n\t\tSELECT COUNT(*) per_num,deptno\n\t\tFROM emp\n\t\tGROUP BY deptno\n\t)temp\n\tWHERE temp.deptno&#x3D;dept.deptno\n\n\n\n表复制和去重#演示表的复制– 为了对某个sql语句进行效率测试，我们需要海量数据时，可以使用此法为表创建海量数据\nCREATE TABLE my_tb01\n\t(id INT,\n\t&#96;name&#96; VARCHAR(32),\n\tsal DOUBLE,\n\tjob VARCHAR(32),\n\tdeptno INT);\n\n– 演示如何自我复制– 1.先把emp表的记录复制到my_tb01\nINSERT INTO my_tb01\n\t(id,&#96;name&#96;,sal,job,deptno)\n\tSELECT empno,ename,sa1,job,deptno FROM emp;\n\n– 2.自我复制\nINSERT INTO my_tb01\n\tSELECT * FROM my_tb01;\n\n– 如何删除掉一张表重复记录– 1.先创建一张表my_tb02– 2.让my_tb02有重复的记录\nCREATE TABLE my_tb02 LIKE emp;\n\n– 把emp表的结构(列)，复制到my_tb02\nINSERT INTO my_tb02\n\tSELECT * FROM emp;\n\n– 3.考虑去重– 分析&#x2F;*    1.先创建一张临时表my_tb，该表的结构与my_tb02一致    2.把my_tb02的记录通过distinct关键字处理后，把记录复制到my_tb    3.清除掉my_tb02记录    4.把my_tb表的记录复制到my_tb02    5.drop掉临时表my_tb*&#x2F;\nCREATE TABLE my_tb LIKE my_tb02;\n\nINSERT INTO my_tb\n\tSELECT DISTINCT * FROM my_tb02;\n\nDELETE FROM my_tb02;\n\nINSERT INTO my_tb02\n\tSELECT * FROM my_tb;\n\t\nDROP TABLE my_tb;\n\n合并查询#演示合并查询\nSELECT ename,sa1,job FROM emp WHERE sa1&gt;2500;\n\nSELECT ename,sa1,job FROM emp WHERE job&#x3D;&#39;manager&#39;\n\n– union all 就是将两个查询结果合并，不会去重\nSELECT ename,sa1,job FROM emp WHERE sa1&gt;2500\nUNION ALL\nSELECT ename,sa1,job FROM emp WHERE job&#x3D;&#39;manager&#39;\n\n– union 该操作赋与 union all相似，但是会自动去掉结果中重复的记录\nSELECT ename,sa1,job FROM emp WHERE sa1&gt;2500\nUNION\nSELECT ename,sa1,job FROM emp WHERE job&#x3D;&#39;manager&#39;\n\n\n\n左外连接与右外连接#演示外连接\n– 比如：列出部门名称和这些部门的员工名称和工作，同时要求显示出那些没有员工的部门\n– 使用我们学习过的多表查询的sql，看看效果如何\nSELECT dname,ename,job\n\tFROM emp,dept\n\tWHERE emp.deptno&#x3D;dept.deptno\n\tORDER BY dname;\n\n#外连接– 1，左外连接 (如果左侧的表完全显示我们就说是左外连接)– 1，右外连接 (如果右侧的表完全显示我们就说是右外连接)\n– 创建stu\nCREATE TABLE stu (\n\tid INT,\n\t&#96;name&#96; VARCHAR(32));\nINSERT INTO stu VALUES(1,&#39;jack&#39;),(2,&#39;tom&#39;),(3,&#39;kity&#39;),(4,&#39;noo&#39;);\n\n– 创建表exam\nCREATE TABLE exam (\n\tid INT,\n\tgrade INT);\nINSERT INTO exam VALUES(1,56),(2,76),(11,8);\n\n– 使用左连接(显示所有人的成绩，如果没有成绩，也要显示该人的姓名和id号，成绩显示为空)&#x2F;*    格式：select…from 表1 left join 表2 on 条件*&#x2F;\nSELECT &#96;name&#96;,stu.id,grade\n\tFROM stu,exam\n\tWHERE stu.id&#x3D;exam.id\n\n– 改成左连接\nSELECT &#96;name&#96;,stu.id ,grade\n\tFROM stu LEFT JOIN exam\n\tON stu.id&#x3D;exam.id\n\n\n– 右外连接(显示所有成绩，如果没有名字匹配，显示空)\nSELECT &#96;name&#96;,grade,exam.id\n\tFROM stu RIGHT JOIN exam\n\tON stu.id&#x3D;exam.id\n\nSELECT dept.deptno,&#96;ename&#96;,job\n\tFROM emp RIGHT JOIN dept\n\tON emp.deptno&#x3D;dept.deptno\n\nSELECT dept.deptno,&#96;ename&#96;,job\n\tFROM dept LEFT JOIN emp\n\tON emp.deptno&#x3D;dept.deptno\n\nMySql约束主键#演示主键使用– id name email\nCREATE TABLE t17 (\n\tid INT PRIMARY KEY, -- 表示id列是主键\n\t&#96;name&#96; VARCHAR(32),\n\temail VARCHAR(32));\n\n– 主键列的值是不可以重复的\nINSERT INTO t17\n\tVALUES(1,&#39;jack&#39;,&#39;jack@sohu.com&#39;),(2,&#39;tom&#39;,&#39;tom@sohu.com&#39;);\n\nINSERT INTO t17 VALUES(1,&#39;lvy&#39;,&#39;lvy@sohu.com&#39;); 添加失败，主键重复\n\n– 主键使用细节– primary key不能重复而且不能为null\nINSERT INTO t17 VALUES(NULL,&#39;gsp&#39;,&#39;gsp@sohu.com&#39;); -- Column &#39;id&#39; cannot be null\n\n– 一张表最多只能有一个主键，但可以是复合主键\nCREATE TABLE t18 (\n\tid INT PRIMARY KEY, \n\t&#96;name&#96; VARCHAR(32) PRIMARY KEY,\n\temail VARCHAR(32)); -- Multiple primary key defined\n\n– 演示复合主键使用(id和name做成复合主键，即id和name做为一个复合主键，而不是id是主键1，name是主键2)\t\nCREATE TABLE t18 (\n\tid INT , \n\t&#96;name&#96; VARCHAR(32),\n\temail VARCHAR(32),\n\tPRIMARY KEY(id,&#96;name&#96;));\n\nINSERT INTO t18 VALUES(1,&#39;gsp&#39;,&#39;gsp@sohu.com&#39;);\nINSERT INTO t18 VALUES(1,&#39;dsa&#39;,&#39;dsa@sohu.com&#39;);\nINSERT INTO t18 VALUES(2,&#39;dsa&#39;,&#39;dsa@sohu.com&#39;);\nINSERT INTO t18 VALUES(1,&#39;gsp&#39;,&#39;gsp@sohu.com&#39;); -- Duplicate entry &#39;1-gsp&#39; for key &#39;PRIMARY&#39;\n\n– 主键的指定方式有两种– 1.直接在字段名后指定：字段名 primary key– 2.在表定义最后写 primary key(列名);– 参考上面创建表的方式– 使用desc表名，可以看到primary key的情况\nDESC t18;\nDESC t17;\n\n– 实际开发中，每个表往往都会设计一个主键\nunique#演示unique使用\nCREATE TABLE t19 (\n\tid INT UNIQUE,-- 表示id列是不可重复的，但可为null\n\t&#96;name&#96; VARCHAR(32),\n\temail VARCHAR(32));\n\t\nINSERT INTO t19 VALUES(1,&#39;jack&#39;,&#39;jack@sohu.com&#39;);-- Duplicate entry &#39;1&#39; for key &#39;id&#39;\nINSERT INTO t19 VALUES(1,&#39;tom&#39;,&#39;tom@sohu.com&#39;);\n\n– unique使用细节– 如果没有指定not null，则unique字段可以有多个null– 如果一个列(字段)是unique not null，那么使用效果类似primary key\nINSERT INTO t19 VALUES(NULL,&#39;jack&#39;,&#39;jack@sohu.com&#39;);\nSELECT * FROM t19;\n\n– 一张表可以有多个unique字段\nCREATE TABLE t20 (\n\tid INT UNIQUE,\n\t&#96;name&#96; VARCHAR(32) UNIQUE,\n\temail VARCHAR(32));\n\n外键#外键演示– 创建主表 my_class\nCREATE TABLE my_class (\n\tid INT PRIMARY KEY, -- 班级编号\n\t&#96;name&#96; VARCHAR(32) NOT NULL DEFAULT &#39;&#39;);\n\n– 创建从表 my_stu\nCREATE TABLE my_stu (\n\tid INT PRIMARY KEY, -- 学生编号\n\t&#96;name&#96; VARCHAR(32) NOT NULL DEFAULT &#39;&#39;,\n\tclass_id INT, -- 学生所在班级的编号\n\n– 下面指定外键关系\nFOREIGN KEY(class_id) REFERENCES my_class(id));\n\n– 测试数据\nINSERT INTO my_class VALUES(100,&#39;java&#39;),(200,&#39;web&#39;);\nSELECT * FROM my_class;\nINSERT INTO my_stu VALUES(1,&#39;tom&#39;,100);\nINSERT INTO my_stu VALUES(2,&#39;jack&#39;,200);\nINSERT INTO my_stu VALUES(3,&#39;mary&#39;,300); -- 失败，因为300号班级不存在\nINSERT INTO my_stu VALUES(4,&#39;king&#39;,NULL); -- 可以，外键没有写not null\n\n– 外键细节– 1.外键指向的表的字段，要求是primary key或者是unique– 2.表的存储引擎是innodb，这样的表才支持外键– 3.外键字段的类型要和主键字段的类型一致(长度可以不同)– 4.外键字段的值，必须在主键字段中出现过，或者为null(前提是外键字段允许为null)– 5.一旦建立主外键的关系，数据不能随意删除了(需要先删除外键对应数据，才能删除主键对应数据)\ncheck#演示check使用– mysql5.7目前还不支持check，只做语法校验，但是不会生效– 但在oracle,sql server这两个数据库中是真的生效\nCREATE TABLE t21 (\n\tid INT PRIMARY KEY,\n\t&#96;name&#96; VARCHAR(32),\n\tsex VARCHAR(6) CHECK (sex IN(&#39;man&#39;,&#39;woman&#39;)),-- 即检查插入的记录是不是这两个字符串，如果是就成功，如果不是就插入失败\n\tsal DOUBLE CHECK (sal&gt;1000 AND sal&lt;2000));\n\n– 添加数据\nINSERT INTO t21 VALUES(1,&#39;jack&#39;,&#39;mid&#39;,1)-- 添加失败(mid不在检查范围内并且sal小于1000)\nSELECT * FROM t21;\n\n自增长#演示自增长的使用– 创建表\nCREATE TABLE t22 (\n\tid INT PRIMARY KEY AUTO_INCREMENT,\n\temail VARCHAR(32) NOT NULL DEFAULT &#39;&#39;,\n\t&#96;name&#96; VARCHAR(32) NOT NULL DEFAULT &#39;&#39;);\nDESC t22;\n\n– 测试自增长的使用\nINSERT INTO t22 VALUES(NULL,&#39;tom@sohu.com&#39;,&#39;tom&#39;);\nINSERT INTO t22 (email,&#96;name&#96;) VALUES(&#39;lvy@sohu.com&#39;,&#39;lvy&#39;);\nSELECT * FROM t22;\n\n– 自增长使用细节– 1.一般来说自增长是和primary key配合使用的– 2.自增长也可以单独使用(但是需要配合一个unique)– 3.自增长修饰的字段为整数型的(虽然小数也可以但是非常非常少这样使用)– 4.自增长默认从1开始，你也可以通过如下命令修改– \talter table 表名 auto_increment&#x3D;xxx;\nALTER TABLE t22 AUTO_INCREMENT&#x3D;10;\nINSERT INTO t22 VALUES(NULL,&#39;jack@sohu.com&#39;,&#39;jack&#39;);\n\n– 5.如果你添加数据时，给自增长字段(列)指定的有值，则以指定的值为准– 6.一般来说，如果指定了自增长，就按照自增长的规则来添加数据，不要自己指定数值&#x2F;*\t同时自增长会从指定的值开始,    比如之前自增长到10，而你添加数据时，    指定了100给自增长字段，    那么自增长会从10直接跳到100重新开始自增长*&#x2F;\nINSERT INTO t22 VALUES(100,&#39;brck@sohu.com&#39;,&#39;brck&#39;);\n\nMySql索引索引优化速度及索引原理– 索引的原理– 没用索引为什么查询海量数据会慢？因为是全表扫描– 使用索引为什么查询海量数据会快？因为形成一个索引的数据结构，比如二叉树– 使用索引的代价– 1.磁盘占用空间变大– 2.对dml(update,delete,insert)语句的执行效率产生影响，变慢\n索引的类型– 1.主键索引，主键自动的为主索引(类型Primary Key)– 2.唯一索引(UNIQUE)– 3.普通索引(INDEX)– 4.全文索引(FULLTEXT)[适用于MylSAM]\nmysql的索引的使用– 创建索引\nCREATE TABLE t23 (\n\tid INT,\n\t&#96;name&#96; VARCHAR(32));\n\n– 查询表是否有索引\nSHOW INDEXES FROM t23;\n\n– 添加索引– 添加唯一索引\nCREATE UNIQUE INDEX id_index ON t23 (id);\n\n– 添加普通索引方法1\nCREATE INDEX id_index ON t23 (id);\n\n– 添加普通索引方法2\nALTER TABLE t23 ADD INDEX id_index (id);\n\n– 如何选择索引类型– 如果某列的值，是不会重复的，则优先考虑使用unique索引，否则使用普通索引\n– 添加主键索引\nCREATE TABLE t24 (\n\tid INT,\n\t&#96;name&#96; VARCHAR(32));\nALTER TABLE t24 ADD PRIMARY KEY (id);\nSHOW INDEX FROM t24;\n\n– 删除索引\nDROP INDEX id_index ON t23;\n\n– 删除主键索引\nALTER TABLE t24 DROP PRIMARY KEY;\n\n– 修改索引– 先删除，在添加新的索引\n– 查询索引– 方式1SHOW INDEX FROM t23;– 方式2SHOW INDEXES FROM t23;– 方式3SHOW KEYS FROM t23;– 方式4DESC t23\n创建索引规则– 哪些列适合使用索引– 1.较频繁的作为查询条件字段应该创建索引– 2.唯一性太差的字段不适合单独创建索引，即使频繁作为查询条件– 3.更新非常频繁的字段不适合创建索引– 4.不会出现在where子句中字段不该创建索引\nMySql事务什么是事务及事务操作？– 事务用于保证数据的一致性，它由一组相关的dml语句组成，该组的dml语句要么全部成功，要么全部失败– 演示mysql数据库控制台事务的几个重要操作– start transaction  开始一个事务– savepoint  设置保存点– rollback to  回退事务– rollback  回退全部事务– commit  提交事务，所有的操作生效，不能回退\n– 1.创建一张表\nCREATE TABLE t25 (\n\tid INT,\n\t&#96;name&#96; VARCHAR(32));\n\n– 2.开始事务\nSTART TRANSACTION\n\n– 3.设置保存点\nSAVEPOINT a\n\n– 执行dml操作\nINSERT INTO t25 VALUES(100,&#39;tom&#39;);\nSELECT * FROM t25;\n\n– 4.设置保存点\nSAVEPOINT b\n\n– 执行dml操作\nINSERT INTO t25 VALUES(200,&#39;jack&#39;);\n\n– 回退到b\nROLLBACK TO b\n\n– 回退到a\nROLLBACK TO a\n\n– 如果这样，表示直接回退到事务开始的状态\nROLLBACK\n\n– 提交事务\nCOMMIT\n\n事务注意细节– 讨论 事务细节– 1.如果不开始事务，在默认情况下，dml操作是自动提交的，不能回滚\nINSERT INTO t25 VALUES(300,&#39;mary&#39;);\nSELECT * FROM t25;\n\n– 2.如果开始一个事务，你没有创建保存点，你可以执行rollback– 默认就是回退到事务开始的状态\nSTART TRANSACTION\nINSERT INTO t25 VALUES(400,&#39;king&#39;);\nINSERT INTO t25 VALUES(500,&#39;scott&#39;);\nROLLBACK\n\n– 3.你也可以在这个事务中(还没有提交时)，创建多个保存点– 4.你可以在事务没有提交前，选择回退到哪个保存点– 5.InnoDB存储引擎支持事务，MyISAM不支持– 6.开始一个事务 start transaction 或者 set autocommit&#x3D;off;\nMySql事务隔离级别4种隔离级别\n\n\n设置隔离#事务隔离级别介绍– 1.多个连接开启各自事务操作数据库中数据时，数据库系统要负责隔离操作– 以保证各个连接在获取数据时的准确性– 2.如果不考虑隔离性，可能会引发如下问题：– 脏读：当一个事务读取另一个事务尚未提交的修改时，产生脏读– 不可重复读：同一查询在同一事务中多次进行，由于其他提交事务所做的– 修改或删除，每次返回不同的结果集，此时发生不可重复读– 幻读：同一查询在同一事务中多次进行，由于其他提交事务所做的插入操作– 每次返回不同的结果集，此时发生幻读\n#演示mysql的事务隔离级别– 1.开了两个mysql的控制台– 2.查看当前mysql的隔离级别\nSELECT @@tx_isolation;\n\nmysql&gt; SELECT @@tx_isolation;\n+-----------------+\n| @@tx_isolation  |\n+-----------------+\n| REPEATABLE-READ |\n+-----------------+\n\n– 3.把其中一个控制台的隔离级别设置 Read uncommitted\nSET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;\n\n– 4.创建表\nCREATE TABLE &#96;account&#96; (\n\tid INT,\n\t&#96;name&#96; VARCHAR(32),\n\tmoney INT);\n\n– 查看当前会话隔离级别\nSELECT @@tx_isolation;\n\n– 查看系统当前隔离级别\nSELECT @@global.tx_isolation;\n\n– 设置当前会话隔离级别\nSET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;\n\n– 设置系统当前隔离级别\nSET GLOBAL TRANSACTION ISOLATION LEVE\n\nMySql表类型与存储引擎表类型和存储引擎\n\n\n– 查看所有存储引擎\nSHOW ENGINES\n\n– innodb 存储引擎– 1.支持事务 2.支持外键 3.支持行级锁\n– myisam 存储引擎– 1.添加数据快 2.不支持外键和事务 3.支持表级锁\nCREATE TABLE t26 (\n\tid INT,\n\t&#96;name&#96; VARCHAR(32)) ENGINE MYISAM\nSTART TRANSACTION\nSAVEPOINT a\nINSERT INTO t26 VALUES(1,&#39;jack&#39;);\nSELECT * FROM t26;\nROLLBACK TO a\n\n– memory 存储引擎– 1.数据存储在内存中(关闭了MySql服务，数据丢失，但是表结构还在) 2.执行速度很快(没有IO读写) 3.默认支持索引(hash表)\nCREATE TABLE t27 (\n\tid INT,\n\t&#96;name&#96; VARCHAR(32)) ENGINE MEMORY\nINSERT INTO t27 VALUES(1,&#39;jack&#39;),(2,&#39;tom&#39;),(3,&#39;mery&#39;);\nSELECT * FROM t27;\n\n– 指令修改存储引擎\nALTER TABLE &#96;t27&#96; ENGINE &#x3D; INNODB;\n\n如何选择表的存储引擎\n视图视图原理\n\n– 1.视图是根据基表(可以是多个基表)来创建的，视图是虚拟的表– 2.视图也有列，数据来自基表– 3.通过视图可以修改基表的数据– 4.基表的改变，也会影响到视图的数据\n视图的使用– 创建一个视图emp_view01，只能查询emp表的(empno,ename,job和deptno)信息– 创建视图\nCREATE VIEW emp_view01\n\tAS\n\tSELECT empno,ename,job,deptno FROM emp;\n\n– 查看视图\nDESC emp_view01;\nSELECT * FROM emp_view01;\nSELECT empno,job FROM emp_view01;\nSELECT sa1 FROM emp_view01; -- Unknown column &#39;sa1&#39; in &#39;field list&#39;\n\n– 查看创建视图的指令\nSHOW CREATE VIEW emp_view01;\n\n– 删除视图\nDROP VIEW emp_view01;\n\n– 视图细节讨论– 1.创建视图后，到数据库去看，对应视图只有一个视图结构文件(形式：视图名.frm)，不会有数据文件(视图名.ibd)– 2.视图的数据变化会影响到基表，基表的数据变化也会影响到视图(insert,update,delete)– 修改视图\nUPDATE emp_view01\n\tSET job&#x3D;&#39;MANAGER&#39;\n\tWHERE empno&#x3D;7369;\nSELECT * FROM emp_view01; -- 查询视图\nSELECT * FROM emp; -- 查询基表\n\n– 修改基表，也会影响到视图\nUPDATE emp\n\tSET job&#x3D;&#39;SALESMAN&#39;\n\tWHERE empno&#x3D;7369;\n\n– 3.视图中可以再使用视图，数据依然来自基表，比如从emp_view01这个视图中选出empno和ename做新视图\nDESC emp_view01;\n\nCREATE VIEW emp_view02\n\tAS\n\tSELECT empno,ename FROM emp_view01;\nSELECT * FROM emp_view02;\n\n– 视图练习– 针对emp，dept和salgrade三张表，创建一个视图emp_view03– 可以显示雇员编号，雇员名，雇员部门名称和薪水级别[即使用三张表，创建一个视图]&#x2F;*    分析：使用三表联合查询，得到结果    将得到的结果，构建成视图*&#x2F;\nCREATE VIEW emp_view03\n\tAS\nSELECT empno,ename,dname,grade\n\tFROM emp,dept,salgrade\n\tWHERE emp.deptno&#x3D;dept.deptno AND \n\t(sa1 BETWEEN losal AND hisal)\nSELECT * FROM emp_view03\n\nMySql管理MySql用户管理– MySql用户的管理– 原因：当我们做项目开发时，可以根据不同的开发人员，赋给他相应的MySql操作权限– 所以，MySql数据库管理人员(root)，根据需要创建不同的用户，赋给相应的权限，供人员使用\n– 1.创建新的用户– 解读(1) ‘lby‘@’localhost’表示用户的完整信息，’lby’用户名，’localhost’登录的IP– (2) 123456表示密码，但是注意，存放到mysql.user表时，是password(‘123456’)加密后的密码\nCREATE USER &#39;lby&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;123456&#39;\n\n– 2.删除用户\nDROP USER &#39;lby&#39;@&#39;localhost&#39;\n\n– 3.修改自己的密码\nSET PASSWORD&#x3D;PASSWORD(&#39;abcdef&#39;)\n\n– 4.修改其他人的密码，需要权限(root用户权限高，可以修改其他用户密码)\nSET PASSWORD FOR &#39;lby&#39;@&#39;localhost&#39;&#x3D;PASSWORD(&#39;123456&#39;)\n\n\nMySql权限管理\n\n– 演示用户权限的管理– 1.创建用户 libai 密码 123，从本地登录\nCREATE USER &#39;libai&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;123&#39;\n\n– 使用root用户创建testdb，表news\nCREATE DATABASE testdb\nCREATE TABLE news (\n\tid INT,\n\tcontent VARCHAR(32));\n\n– 添加一条测试数据\nINSERT INTO news VALUES(100,&#39;广州新闻&#39;)\nSELECT * FROM news\n\n– 给libai分配查看news表和添加news的权限\nGRANT SELECT,INSERT\n\tON testdb.news\n\tTO &#39;libai&#39;@&#39;localhost&#39;\n\n– 给libai增加权限\nGRANT UPDATE\n\tON testdb.news\n\tTO &#39;libai&#39;@&#39;localhost&#39;\n\n– 修改libai的密码为abc\nSET PASSWORD FOR &#39;libai&#39;@&#39;localhost&#39;&#x3D;PASSWORD(&#39;abc&#39;)\n\n– 回收libai用户在testdb.news表的所有权限\nREVOKE SELECT,UPDATE,INSERT ON testdb.news FROM &#39;libai&#39;@&#39;localhost&#39;\nREVOKE ALL ON testdb.news FROM &#39;libai&#39;@&#39;localhost&#39;\n\n– 如果权限没有生效，可以执行下面的指令\nFLUSH PRIVILEGES\n\nMySql用户管理细节#说明用户管理的细节– 在创建用户的时候，如果不指定Host，则为%，%表示所有IP都有连接权限– create user xxx;\nCREATE USER jack\nSELECT &#96;host&#96;,&#96;user&#96; FROM mysql.user\n\n– 你也可以这样子指定– *create user ‘xxx‘@’192.168.1.%’表示xxx用户在192.168.1.的ip可以登录mysql\nCREATE USER &#39;smith&#39;@&#39;192.168.1.%&#39;\n\n– 在删除用户时，如果host不是%，需要明确指定’用户‘@’host值’\nDROP USER jack -- 默认就是drop user &#39;jack&#39;@&#39;%&#39;\nDROP USER &#39;smith&#39;@&#39;192.168.1.%&#39;\n\n","slug":"MySqlNote","date":"2022-12-19T07:36:00.000Z","categories_index":"分享","tags_index":"","author_index":"Humble"},{"id":"ded61a19544260ae868539b13c770d4b","title":"Java-3","content":"4.String1.概述String是引用数据类型，在java中用于存放字符串\n2.特点-字符串不可变，它们的值在创建后不能被更改\n-虽然String的值是不可变的，但是它们可以被共享\n-字符串效果上相当于字符数组(char[])，但是底层原理是字节数组(byte[])\n3.构造方法\nclass StringDemo &#123;\n    public static void main(String[] args) &#123;\n        //public String()，创建一个空白字符串对象，不含有任何内容\n        String s1=new String();\n        System.out.println(\"s1=\"+s1); //输出结果为 s1=\n        //public String(char[] arr),根据字符数组的内容，来创建字符串对象\n        char[] arr=&#123;'a','b','c'&#125;;\n        String s2=new String(arr);\n        System.out.println(\"s2=\"+s2);//输出结果为 s2=abc\n        //public String(bytr[] arr1)，根据字节数组的内容，来创建字符串对象\n        byte[] arr1=&#123;97,98,99&#125;;//97=a,98=b,99=c\n        String s3=new String(arr1);\n        System.out.println(\"s3=\"+s3);//输出结果为 s3=abc\n        //String s=\"abc\";直接赋值的方式创建字符串对象，内容就是abc\n        String s4=\"abc\";\n        System.out.println(\"s4=\"+s4);\n    &#125;\n&#125;\n\n4.String对象的特点4.1.通过new创建的字符串对象，每一次new都会申请一个内存空间，虽然内容相同，但是地域值不同\n4.2.以””方式给出的字符串，只要字符序列相同(顺序和大小写)，无论在程序代码中出现几次，JVM都只会建立一个String对象，并在字符串池种维护\n4.3.存储分析\n\n\n\n\n5.字符串的比较使用**&#x3D;&#x3D;**做比较\n-基本类型：比较的是数据值是否相同\n-引用类型：比较的是地址值是否相同\n字符串是对象，它比较内容是否相同，是通过一个方法来实现的，这个方法叫：equals()\n-public boolean equals(Object anObject)：将此字符串与指定对象进行比较，由于我们比较的是对象，所以参数直接传递一个字符串\n6.案例6.1遍历字符串\nimport java.util.Scanner;\npublic class Tttast &#123;\n    public static void main(String[] args) &#123;\n        Scanner sc=new Scanner(System.in);\n        String s=sc.next();\n        int len=s.length();\n        char[] arr=new char[len];\n        for(int i=0;i&lt;len;i++)&#123;\n            arr[i]=s.charAt(i);\n            System.out.print(arr[i]+\" \");\n        &#125;\n    &#125;\n&#125;\n输入14567\n运行结果为\n1 4 5 6 7\n6.2统计字符次数\nimport java.util.Scanner;\npublic class StringTest &#123;\n    public static void main(String[] args) &#123;\n        Scanner sc=new Scanner(System.in);\n        String s=sc.next();\n        int big=0,small=0,num=0;\n        for(int i=0;i&lt;s.length();i++)&#123;\n            char ch=s.charAt(i);\n            if(ch>='A'&amp;&amp;ch&lt;='Z')&#123;\n                big++;\n            &#125;else if(ch>='a'&amp;&amp;ch&lt;='z')&#123;\n                small++;\n            &#125;else if(ch>='0'&amp;&amp;ch&lt;='9')&#123;\n                num++;\n            &#125;\n        &#125;\n        System.out.println(\"big:\"+big);\n        System.out.println(\"small:\"+small);\n        System.out.println(\"num:\"+num);\n    &#125;\n&#125;\n输入：AA2022libo\n输出：big：2\n     small：4\n     num：4\n6.3拼接字符串\nclass StringTest01 &#123;\n    public static void main(String[] args) &#123;\n        int[] arr=&#123;1,2,3&#125;;\n        String s=Arr(arr);\n        System.out.println(s);\n    &#125;\n    public static String Arr(int[] arr1)&#123;\n        String s=\"\";\n        s+=\"[\";\n        for(int i=0;i&lt;arr1.length;i++)&#123;\n            if(i==arr1.length-1)&#123;\n                s+=arr1[i];\n            &#125;else&#123;\n                s+=arr1[i];\n                s+=\", \";\n            &#125;\n        &#125;\n        s+=\"]\";\n        return s;\n    &#125;\n&#125;\n输出:[1, 2, 3]\n6.4字符串反转\nclass StringTest02 &#123;\n    public static void main(String[] args) &#123;\n        Scanner sc=new Scanner(System.in);\n        String s=sc.next();\n        String sss=Arr(s);\n        System.out.println(sss);\n    &#125;\n    public static String Arr(String ss)&#123;\n        char[] arr=new char[ss.length()];\n        String s=\"\";\n        s+=\"[\";\n        for(int i=ss.length()-1,j=0;i>=0;i--,j++)&#123;\n            arr[j] = ss.charAt(i);\n            if(i==0)&#123;\n                s +=arr[j];\n            &#125;else &#123;\n                s += arr[j];\n                s += \", \";\n            &#125;\n        &#125;\n        s+=\"]\";\n        return s;\n    &#125;\n&#125;\n输入：abcde\n输出：[e, d, c, d, a]\n7.通过帮助文档查看String中的方法即API查看\n\n8.常用方法1.00.boolean\tequals(Object anObject)\n将此字符串与指定对象进行比较。 区分大小写，判断内容是否相等\n1.boolean\tequalsIgnoreCase(String anotherString)\n将此 String与其他 String比较，忽略案例注意事项。忽略大小写的判断内容是否相等\n2.int\tindexOf(int ch)\n返回指定字符第一次出现的字符串内的索引。索引从0开始，如果找不到，返回-1\n3.int\tlastIndexOf(int ch)\n返回指定字符的最后一次出现的字符串中的索引。索引从0开始，如果找不到，返回-1\n4.String\tsubstring(int beginIndex)\n返回一个字符串，该字符串是此字符串的子字符串。即截取指定范围的字符串\n5.String\tsubstring(int beginIndex, int endIndex)\n返回一个字符串，该字符串是此字符串的子字符串。即截取指定范围的字符串\n6.String\ttrim()\n返回一个字符串，其值为此字符串，并删除任何前导和尾随空格。即删除前后空格\n\npublic class StringDemo01 &#123;\n    public static void main(String[] args) &#123;\n//        boolean  equals(Object anObject)区分大小写，判断内容是否相等\n        String s1=\"hello\";\n        String s2=\"Hello\";\n        System.out.println(s1.equals(s2));//false\n//        boolean  equalsIgnoreCase(String anotherString)忽略大小写的判断内容是否相等\n        String s3=\"hello\";\n        String s4=\"Hello\";\n        System.out.println(s3.equalsIgnoreCase(s4));//true\n//        int  indexOf(int ch)返回指定字符第一次出现的字符串内的索引。索引从0开始，如果找不到，返回-1\n        String s5=\"hello@java@li\";\n        int index=s5.indexOf('@');\n        int index2=s5.indexOf('$');\n        int index5=s5.indexOf(\"java\");\n        System.out.println(index+\" \"+index2+\" \"+index5);//5 -1 6\n//        int  lastIndexOf(int ch)返回指定字符的最后一次出现的字符串中的索引。索引从0开始，如果找不到，返回-1\n        String s6=\"hello@java@li\";\n        int index3=s6.lastIndexOf('@');\n        int index4=s6.lastIndexOf('$');\n        int index6=s6.lastIndexOf(\"java\");\n        System.out.println(index3+\" \"+index4+\" \"+index6);//10 -1 6\n//          String substring(int beginIndex)返回一个字符串，该字符串是此字符串的子字符串。即截取指定范围的字符串\n        String s7=\"hello,李白\";\n//        s7.substring(6)表示从索引6开始截取后面所有的内容\n        System.out.println(s7.substring(6));//李白\n//        String   substring(int beginIndex, int endIndex返回一个字符串，该字符串是此字符串的子字符串。即截取指定范围的字符串\n//        s7.substring(0,5)表示从索引0开始截取，截取到索引5-1=4这个位置\n        System.out.println(s7.substring(0,5));//hello\n//         String  trim()返回一个字符串，其值为此字符串，并删除任何前导和尾随空格。即删除前后空格\n        String s8=\"   hello world   \";\n        System.out.println(s8.trim());//hello world\n    &#125;\n&#125;\n2.00.String\treplace(char oldChar, char newChar)\n返回从替换所有出现的导致一个字符串 oldChar在此字符串 newChar 。即替换字符串中的字符\n1.int\tcompareTo(String anotherString)\n按字典顺序比较两个字符串。即比较两个字符串的大小\n2.char[]\ttoCharArray()\n将此字符串转换为新的字符数组。即把字符串转换为字符数组\n3.String\tconcat(String str)\n将指定的字符串连接到该字符串的末尾。 \n4.String\ttoLowerCase()\n将所有在此字符 String使用默认语言环境的规则，以小写。 \n5.String\ttoUpperCase()\n将所有在此字符 String使用默认语言环境的规则大写。 \n6.String[]\tsplit(String regex)\n将此字符串分割为给定的 regular expression的匹配。即分割字符串，对于某些分割字符，需要转义，比如|\\\\等\n\npublic class StringDemo02 &#123;\n    public static void main(String[] args) &#123;\n//        String   replace(char oldChar, char newChar)返回从替换所有出现的导致一个字符串 oldChar在此字符串 newChar 。即替换字符串中的字符\n    String s=\"hello world\";\n//        s.replace()方法执行后，返回的结果才是替换过的\n//        对s本身没有任何影响\n        String ss=s.replace(\"hello\",\"Hello\");\n        System.out.println(ss);//Hello world\n        System.out.println(s);//hello world\n//        除非用s本身来接收替换的结果，s才会有变化\n        s=s.replace(\"hello\",\"Hello\");\n        System.out.println(s);//Hello world\n//        int  compareTo(String anotherString)按字典顺序比较两个字符串。即比较两个字符串的大小\n//        如果前者大，则返回正数，如果后者大，则返回负数，如果相等，则返回0\n        String s1=\"jcva\";\n        String s2=\"java\";\n        System.out.println(s1.compareTo(s2));//返回值是'c'-'a'=2的值\n//      char[] toCharArray()将此字符串转换为新的字符数组。即把字符串转换为字符数组\n        String s3=\"happy\";\n        char[] arr=s3.toCharArray();\n        for(int i=0;i&lt;s3.length();i++) &#123;\n            System.out.print(arr[i] + \" \");//h a p p y\n        &#125;\n//       String    concat(String str)将指定的字符串连接到该字符串的末尾。\n            String s4=\"李白\";\n           s4 = s4.concat(\"爱\").concat(\"写诗\").concat(\"和喝酒\");\n            System.out.println(s4);//李白爱写诗和喝酒\n//        String toLowerCase()将所有在此字符 String使用默认语言环境的规则，以小写。\n        String s5=\"Hello\";\n        System.out.println(s5.toLowerCase());//hello\n//        String   toUpperCase()将所有在此字符 String使用默认语言环境的规则大写。\n        System.out.println(s5.toUpperCase());//HELLO\n//        String[] split(String regex)将此字符串分割为给定的 regular expression的匹配。即分割字符串，对于某些分割字符，需要转义，比如|\\\\等\n       String s6=\"锄禾日当午，汗滴禾下土，谁知盘中餐，粒粒皆辛苦\";\n       String[] s7=s6.split(\"，\");\n        System.out.println(s7[0]);//锄禾日当午\n       for(String poem:s7)&#123;\n           System.out.print(poem+\" \");//锄禾日当午 汗滴禾下土 谁知盘中餐 粒粒皆辛苦\n       &#125;\n       String s8=\"C:\\\\Tast\\\\java\";\n       String[] s9=s8.split(\"\\\\\\\\\");\n            for(String luji:s9)&#123;\n                System.out.print(luji+\" \");//C: Tast java\n            &#125;\n        &#125;\n        &#125;\n5.StringBuilder1.概述\n-StringBuilder是一个可变的字符串类，我们可以把它看成是一个容器\n-这里的可变指的是StringBuilder对象中的内容是可变的\n2.构造方法\nclass StringBuilder01 &#123;\n    public static void main(String[] args) &#123;\n//public StringBuilder(),创建一个空白的字符串对象，不含有任何内容\n        StringBuilder s1=new StringBuilder();\n     System.out.println(\"s1:\"+s1+\" \"+s1.length());\n//public StringBuilder(String str),根据字符串的内容，来创建可变字符串对象\n        StringBuilder s2=new StringBuilder(\"hello\");\n        System.out.println(\"s2:\"+s2+\" \"+s2.length());\n    &#125;\n&#125;\n输出：s1：0\n     s2：hello 5\n3.添加和反转方法\nclass StringBuilder02 &#123;\n    public static void main(String[] args) &#123;\n//        创建对象\n        StringBuilder s=new StringBuilder();\n/*        public StringBuilder append(任意类型);添加类型,并返回对象本身\n       StringBuilder s1=s.append(\"hello\");\n      System.out.println(\"s:\"+s);\n      System.out.println(\"s1:\"+s1);\n      System.out.println(s==s1);\n      输出s：hello\n          s1:hello\n          true\n */\n   /*     s.append(\"hello\");\n        s.append(\"world\");\n        s.append(\"java\");\n        s.append(100);\n        System.out.println(\"s:\"+s);\n       输出：helloworldjava100\n    */\n        s.append(\"hello\").append(\"world\").append(\"java\").append(100);\n        System.out.println(\"s:\"+s);\n//         输出：helloworldjava100\n//        public StringBuilder reverse();返回相反的字符序列\n        s.reverse();\n        System.out.println(\"s:\"+s);\n//        输出：s:001avajdlrowolleh\n    &#125;\n&#125;\n4.StringBuilder和String相互转换4.1 StringBuilder转换为Stringpublic String toString(_)：通过toString()就可以实现把StringBuilder转换为Strng\nStringBuilder s=new StringBuilder();\ns.append(\"hello\");\nString s1=s;//这个是错误的\nString s1=s.toString();\n4.2 String转换为StringBuilderpublic StringBuilder(String s)：通过构造方法就可以把String转换为StringBuilder\nString s=\"hello\";\nStringBuilder s1=s;//这个是错误的\nStringBuilder s1=new StringBuilder(s);\n5.案例5.1拼接字符串\nclass StringBuilder03 &#123;\n    public static void main(String[] args) &#123;\n        int[] arr=&#123;1,2,3&#125;;\n        String s=Arr(arr);\n        System.out.println(s);\n    &#125;\n    public static String Arr(int[] arr1)&#123;\n        StringBuilder s=new StringBuilder();\n        s.append(\"[\");\n        for(int i=0;i&lt;arr1.length;i++)&#123;\n            if(i== arr1.length-1)&#123;\n                s.append(arr1[i]);\n            &#125;else&#123;\n                s.append(arr1[i]).append(\", \");\n            &#125;\n        &#125;\n        s.append(\"]\");\n        String s1=s.toString();\n        return s1;\n    &#125;\n&#125;\n5.2字符串反转\n&#96;&#96;&#96;plainclass StringBuilder04 {    public static void main(String[] args) {        Scanner sc&#x3D;new Scanner(System.in);        String ss&#x3D;sc.next();        String sss&#x3D;Arr(ss);        System.out.println(sss);    }    public static String Arr(String s){&#x2F;&#x2F;        StringBuilder s1&#x3D;new StringBuilder(s);&#x2F;&#x2F;        s1.reverse();&#x2F;&#x2F;        String s3&#x3D;s1.toString();&#x2F;&#x2F;        return s3;      return new StringBuilder(s).reverse().toString();    }}输入：1234输出：4321\n","slug":"java-4","date":"2022-11-26T05:00:00.000Z","categories_index":"分享","tags_index":"","author_index":"Humble"},{"id":"eb5f65a0fd8d3397e178ed169f824687","title":"Java-2","content":"3.类与对象1.定义类：类是对现实生活中一类具有共同属性和行为事物的抽象\n对象：万物皆对象，客观存在的事物皆为对象，每个对象的每个属性都拥有特定的值\n\n2.类与对象的关系类是对象的抽象\n对象是类的实体\n\n3.面向对象即面向一个具体的事物的过程\n4.对象的使用\npublic class StudentDemo &#123;\n    public static void main(String[] args) &#123;\n        Student s = new Student();\n        s.age = 18;\n        s.name = \"李白\";\n        s.score = 100.0;\n        System.out.println(s.age+\" \"+s.score+\" \"+s.name);\n\n        s.study();\n        s.dohomework();\n    &#125;\n&#125;\n\n class Student &#123;\n\n    String name;\n    int age;\n    double score;\n\n    public void study() &#123;\n        System.out.println(\"好好学习，天天向上\");\n    &#125;\n    public void dohomework() &#123;\n        System.out.println(\"键盘敲乱，月薪过万\");\n    &#125;\n&#125;\n运行结果为\n18 100.0 李白\n好好学习，天天向上\n键盘敲乱，月薪过万\n5.对象内存图5.1单个对象\n\n\n\n\n\n5.2多个对象\n\n\n\n\n\n5.3多个对象指向相同\n\n\n\n\n6.成员变量和局部变量6.1介绍成员变量：类中方法外的变量\nString name;         int age;\n局部变量：方法中的变量\nint i&#x3D;0;           int j&#x3D;0;\n\n6.2区别\n7.封装7.1private关键字-是一个权限修饰符\n-可以修饰成员(成员变量和成员方法)\n-作用是保护成员不被别的类使用，被private修饰的成员只在本类中访问\n针对private修饰的成员变量，如果需要被其他类使用，提供相应的操作\n-提供”get变量名()“方法，用于获取成员变量的值，方法用public修饰\n-提供”set变量名(参数)“方法，用于设置成员变量的值，方法用public修饰\n7.2this关键字this修饰的变量用于指代成员变量\n-方法的形参如果与成员变量同名，不带this修饰的变量值指的是形参，而不是成员变量\n-方法的形参没有与成员变量同名，不带this修饰的变量指的是成员变量\n\n7.3this内存原理\n\n\n\n7.4封装1.概述-是面向对象的三大特征之一(封装，继承，多态)\n-是面向对象编程语言对客观世界的模拟，客观世界里成员变量都是隐藏在对象内部的，外界是无法直接操作的\n2.原则-将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问\n-成员变量private，提供对应的gextXxx()方法\n3.好处-通过方法来控制成员变量的操作，提高了代码的安全性\n-把代码用方法进行封装，提高了代码的复用性\n8.构造方法8.1概述构造方法是一种特殊的方法\n作用：创建对象\n\n8.2注意事项1.构造方法的创建\n-如果没有定义构造方法，系统将给出一个默认的无参数构造方法\n-如果定义了构造方法，系统将不再提供默认的构造方法\n2.构造方法的重载\n-如果自定义了带参数构造方法，还要使用无参数构造方法，就必须再写一个无参数构造方法\n3.推荐的使用方式\n-无论是否使用，都手工书写无参数构造方法\n8.3标准类的使用public class StudentDemo &#123;\n    public static void main(String[] args) &#123;\n        Student s = new Student();\n        s.setName(&quot;李白&quot;);\n        s.setAge(18);\n       Student s1=new Student(&quot;李白&quot;,19);\n        s1.show();\n    &#125;\n&#125;\n    class Student &#123;\n    private String name;\n    private int age;\n    public Student()&#123;\n        System.out.println(&quot;无参数构造方法&quot;);\n    &#125;\n    public Student(String name,int age) &#123;\n        this.name = name;\n        this.age = age;\n    &#125;\n    public void setName(String name)&#123;\n        this.name=name;\n     &#125;\n     public String getName()&#123;\n        return name;\n     &#125;\n     public void setAge(int age)&#123;\n        this.age=age;\n     &#125;\n     public int getAge()&#123;\n        return age;\n     &#125;\n     public void show()&#123;\n        System.out.println(name+&quot; &quot;+age);\n     &#125;\n    &#125;\n\n","slug":"java-3","date":"2022-11-26T04:00:00.000Z","categories_index":"分享","tags_index":"","author_index":"Humble"},{"id":"caa3a045de76bb58da4a9706c357cf42","title":"Java-1","content":"1.数组1.介绍  数组可以存放多个同一类型的数据。数组也是一种数据类型，是引用类型。\n\n即：数组就是一组数据。\n/*1.int[] arr 表示是int类型的数组，数组名是arr\n2.&#123;1，2，3，4，5&#125;表示数组的值/元素，依次表示数组的第几个元素\n3.可以通过数组名加索引/下标来使用数组中的元素，即arr[索引/下标]\n4.索引/下标是从0开始的，开始编号的第一个元素就是arr[0]\n5.第二个元素就为arr[1],依此类推，最后的元素为arr[arr.length-1]*/\n\npublic class Matrix1 &#123;\n    public static void main(String[] args) &#123;\n    int[] arr=&#123;1,2,3,4,5&#125;;\n//通过for循环来使用元素\n    for(int i=0;i&lt;arr.length;i++)&#123;//通过数组名.length来获取数组长度\n        System.out.print(arr[i]+\" \");\n      &#125;\n  &#125;\n&#125;\n2.使用方式1.使用方式1-动态初始化  数组的定义：\n\n  数据类型 数组名[]=new 数据类型[大小];\n\n  int a[]=new int[5];//创建了一个数组，名字为a，存放5个int类型数据\n\nclass Array01 &#123;\n   public static void main(String[] args) &#123;&#125;\n    int[] arr=new int[5];\n&#125;\n2.使用方式2-动态初始化   先声明数组：\n\n   语法：数据类型 数据名[]; or 数据类型[] 数据名；\n\nint a[]; or ine[] a;\n   创建数组：\n   语法：数组名=new 数据类型[大小];\n\na = new int[5];\n演示：\nclass Array01 &#123;\n   public static void main(String[] args) &#123;&#125;\n    int[] arr；\n    arr = new int[5];\n&#125;\n3.使用方式3-静态初始化初始化数组：\n语法：数据类型[] 数组名&#x3D;{元素值,元素值……};\nint[] arr=&#123;1,2,3,4,5&#125;;\n//相当于：int[] a=new int[5];\na[0]=1;a[1]=2;a[2]=3;a[3]=4;a[4]=5;\n演示：\nclass Array01 &#123;\n   public static void main(String[] args) &#123;&#125;\n    int[] arr=&#123;1，2，3，4，5&#125;；\n&#125;\n3.注意事项   1.数组是多个相同类型的组合，实现对这些数据的统一管理\n   2.数组中的元素可以是任何数据类型，包括基本类型和引用类型，但不能混用\nint[] arr=&#123;1,2.2,3,\"哈哈\"&#125;其中\"哈哈\"为字符串类型，其他为int类型，如果这样子写，会报错，类型不兼容\n   3.数组创建后，如果没有赋值，有默认值：int,short,byte,long皆为0，float和double为0.0，char为\\u0000，boolean为false，String为null   4.使用数组的步骤：声明数组并开辟内存空间–给数组中的元素赋值–使用数组\n   5.数组的索引从0开始\n   6.数组的索引必须在有效范围内使用，不然会出现以下保错\nArrayIndexOutOfBoundsException，即索引超过了有效范围内\n     7.数组属于引用类型，数组型数据是对象(object)\n\n4.数组赋值机制public class Array02 &#123;\n  public static void main(String[] args) &#123;\n  //基本数据类型赋值，赋值方式为值复制/拷贝\n  //N2的变化不会影响n1的值\n  int n1=10;\n  int N2=n1;\n  \n  N2=80;\n  System.out.println(n1);//10\n  System.out.println(N2);//80\n  \n//数组在默认情况下是引用传递，赋的值是地址，赋值方式为引用传递\n//传递的是一个地址，arr2的变化会影响到arr1\n  int[] arr1=&#123;1,2,3&#125;;\n  int[] arr2=arr1;//把arr1的值赋给arr2\n  arr2[0]=10;\n  //看看arr1的值\n  for(int i=0;i&lt;arr1.length;i++)&#123;\n    System.out.println(arr[i]);\n    //输出结果为10，2，3\n  &#125;\n  &#125;\n&#125;\n5.数组拷贝 即将数组arr的元素拷贝到arr1数组，并且要求开辟一个新的独立的空间，大小与arr相同\nclass Array03 &#123;\n   public static void main(String[] args) &#123;\n       int[] arr=&#123;1,2,3&#125;;\n       int[] arr1=new int[3];\n       for(int i=0;i&lt;arr.length;i++)&#123;\n           arr1[i]=arr[i];\n           System.out.print(arr1[i]+\" \");\n       &#125;\n //这时你再改变arr1元素的值，不会影响到arr的元素的值\n       arr1[0]=10;\n       System.out.print(arr1[0]+\" \"+arr[0]);//输出结果为10 1\n   &#125;\n&#125;\n//因为arr1在栈中生成地址指向的堆内存空间和arr在栈中生成地址指向的堆内存空间不同\n6.数组翻转  即将用先数组的元素排序逆过来，如{1,2,3,4,5,6}翻转后成{6,5,4,3,2,1}\n思路-1//通过找规律翻转\nclass Array04 &#123;\n    public static void main(String[] args) &#123;\n        int[] arr=&#123;11,22,33,44,55,66&#125;;\n/*把arr[0]和arr[5]交换，获得&#123;66,22,33,44,55,11&#125;\n  再把arr[1]和arr[4]交换，获得&#123;66,55,33,44,22,11&#125;\n  最后把arr[2]和arr[3]交换，获得&#123;66,55,44,33,22,11&#125;\n  一共要进行3次交换=arr.length/2，每次交换，对应的索引为arr[i]和arr[arr.length-1-i]\n  先创建一个临时变量用来存放arr[i]或arr[arr.length-i-1]\n */\n        int temp=0;\n        int chang=arr.length;\n        for(int i=0;i&lt;chang/2;i++)&#123;\n            temp=arr[i];\n            arr[i]=arr[arr.length-1-i];\n            arr[arr.length-1-i]=temp;\n        &#125;\n        for(int i=0;i&lt;chang;i++)&#123;\n            System.out.print(arr[i]+\" \");\n        &#125;\n    &#125;\n &#125;\n 运行结果为\n66 55 44 33 22 11\n思路-2//通过逆序翻转方式\nclass Array05 &#123;\n    public static void main(String[] args) &#123;\n        int[] arr=&#123;11,22,33,44,55,66&#125;;\n/*先创建一个新的数组arr2，大小与arr。length相同\n  逆序遍历arr，将每个元素拷贝到arr2中\n  再将arr指向arr2，此时arr原先的数据空间就没有变量运用，会被JVM当作垃圾处理掉\n */\n        int[] arr2=new int[arr.length];\n        for(int i=0,j=arr.length-1;i&lt;arr.length;i++,j--)&#123;\n            arr2[i]=arr[j];\n        &#125;\n        arr=arr2;\n        for(int i=0;i&lt;arr.length;i++)&#123;\n            System.out.print(arr[i]+\" \");\n        &#125;\n    &#125;\n &#125;\n 运行结果为\n66 55 44 33 22 11\n7.数组扩容  即给一个定义好的数组增加元素(动态添加)，两个案例：\n案例-1class ArrayAdd &#123;\n        public static void main(String[] args) &#123;\n/*要求:实现动态的给数组添加元素效果，实现对数组扩容\n  1.原始数组使用静态分配int[] arr=&#123;1,2,3&#125;\n  2.增加的元素4，直接放在数组的最后arr=&#123;1,2,3,4&#125;\n  \n  思路分析\n  1.定义初始数组int[] arr=&#123;1,2,3&#125;\n  2.定义一个新的数组int[] arr2=new int[arr.length+1]\n  3.遍历arr数组，依次将arr的元素拷贝到arr2数组\n  4.再将4赋值给arr2[arr.length]=4或arr2[arr2.length-1]\n  5.最后将arr指向arr2，实现arr的扩容，原来arr的数组被销毁\n */\n            int[] arr=&#123;1,2,3&#125;;\n            int[] arr2=new int[arr.length+1];\n            for(int i=0;i&lt;arr.length;i++) &#123;\n                arr2[i] = arr[i];\n            &#125;\n            for(int i=0;i&lt; arr2.length;i++)&#123;\n                arr2[arr2.length-1]=addnumber;\n                arr=arr2;\n                System.out.print(arr[i]+\" \");\n            &#125;\n        &#125;\n    &#125;\n 运行结果为\n\n1 2 3 4\n案例-2import java.util.Scanner;\nclass ArrayAdd &#123;\n        public static void main(String[] args) &#123;\n/*要求:实现动态的给数组添加元素效果，实现对数组扩容\n  1.原始数组使用静态分配int[] arr=&#123;1,2,3&#125;\n  2.增加的元素4，直接放在数组的最后arr=&#123;1,2,3,4&#125;\n  3.用户可以通过如下方法来决定是否继续添加，添加成功，是否继续yes/no\n  \n  思路分析\n  1.定义初始数组int[] arr=&#123;1,2,3&#125;\n  2.定义一个新的数组int[] arr2=new int[arr.length+1]\n  3.遍历arr数组，依次将arr的元素拷贝到arr2数组\n  4.再将4赋值给arr2[arr.length]=4或arr2[arr2.length-1]\n  5.最后将arr指向arr2，实现arr的扩容，原来arr的数组被销毁\n  6.创建一个Scanner对象可以接受用户输入\n  7.因为用户什么时候退出不确定，可以使用do-while循环来控制\n */\n            Scanner sc=new Scanner(System.in);\n            int[] arr=&#123;1,2,3&#125;;\n            do&#123;\n            int[] arr2=new int[arr.length+1];\n            for(int i=0;i&lt;arr.length;i++) &#123;\n                arr2[i] = arr[i];\n            &#125;\n            System.out.println(\"请输入你要添加的元素\");\n            int addnumber=sc.nextInt();\n            for(int i=0;i&lt; arr2.length;i++)&#123;\n                arr2[arr2.length-1]=addnumber;\n                arr=arr2;\n                System.out.print(arr[i]+\" \");\n            &#125;\n            System.out.println(\"是否继续添加\");\n            String key=sc.next();\n            if(key.equals(\"no\"))\n            break;\n            &#125;while(true);\n            System.out.println(\"你退出了添加\");\n        &#125;\n    &#125;\n运行结果为\n请输入你要添加的元素\n4\n1 2 3 4\n是否继续添加\nyes\n请输入你要添加的元素\n5\n1 2 3 4 5 \n是否继续添加\nno\n你退出了添加\n8.数组缩减即给一个定义好的数组缩减元素\nclass ArrayReduce &#123;\n    public static void main(String[] args) &#123;\n        Scanner sc=new Scanner(System.in);\n        int[] arr=&#123;1,2,3,4,5&#125;;\n        do&#123;\n            int[] arr2=new int[arr.length-1];\n            for(int i=0;i&lt;arr.length-1;i++)&#123;\n                arr2[i]=arr[i];\n            &#125;\n            arr=arr2;\n            for(int i=0;i&lt;arr.length;i++) &#123;\n                System.out.print(arr[i]+\" \");\n            &#125;\n            System.out.println(\"\\n是否继续缩减\");\n            String num=sc.next();\n            if(num.equals(\"no\"))\n                break;\n            if(arr.length==1)//当缩减到最后一个元素时退出循环\n                break;\n        &#125;while(true);\n        System.out.print(\"你退出了缩减\");\n    &#125;\n&#125;\n9.冒泡排序介绍冒泡排序(Bubble Sorting)的基本思想时：通过对待排序序列从后往前(从索引较大的元素开始)，依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就像水底下的气泡一样逐渐向上冒。\n分析\n案例class BubbleSort2 &#123;\n    public static void main(String[] args) &#123;\n        int[] arr=&#123;12,23,11,24,25,13&#125;;\n        int temp=0;\n//根据冒泡法的规律可以发现一个数组需要进行排序的次数会等于数组的长度-1\n        for(int i=0;i&lt;arr.length-1;i++)&#123;\n/*根据冒泡法的规律：每一次排序交换的次数会依次减少，如第一次排序交换的次数为arr.length\n-1,第二次排序交换的次数为arr.length-2,以此类推，到最后交换1次\n            for(int j=0;j&lt;arr.length-1-i;j++)&#123;\n                if(arr[j]>arr[j+1])&#123;\n                    temp = arr[j];\n                    arr[j]=arr[j+1];\n                    arr[j+1]=temp;\n                &#125;\n            &#125;\n        &#125;\n        for(int i=0;i&lt;arr.length;i++)&#123;\n            System.out.print(arr[i]+\" \");\n        &#125;\n    &#125;\n&#125;\n运行结果为\n11 12 13 23 24 25\n10.查找即在数组内查找一个指定的元素，然后输出这个元素的索引值\nclass ShuZi &#123;\n    public static void main(String[] args) &#123;\n    Scanner sc=new Scanner(System.in);\n    int num=sc.nextInt();\n    int[] arr=&#123;888,666,123,-123,250,13,250,-222&#125;;\n    int temp=0;\n    for(int i=0;i&lt;arr.length;i++)&#123;\n        temp=i+1;\n        if(num==arr[i])&#123;\n            System.out.print(temp+\" \");\n        &#125;else&#123;\n\n        &#125;\n    &#125;\n    &#125;\n&#125;\n2.方法1.概述\n方法是将具有独立功能的代码块组织成为一个整体，使其具有特殊功能的代码集\n注意：方法必须先创建才可以使用，该过程称为方法定义\n  方法创建后并不是直接运行的，需要手动使用后才执行，该过程被称为方法调用\n2.方法定义和调用2.1方法定义2.2方法调用2.3案例class MethodDemo &#123;\npublic static void main(String[] args) &#123;\n    isONumber();\n&#125;\n    public static void isONumber()&#123;\n        int number=10;\n        if(number%2==0)&#123;\n            System.out.print(true);\n        &#125;else&#123;\n            System.out.print(false);\n        &#125;\n    &#125;\n&#125;\n//运行结果为\ntrue\n3.方法调用过程分析\n1.先执行程序主入口，进入主方法里面再往下执行，发现到isEvenNumber方法的调用，就把isEvenNumber这个方法调用出来\n2.进入到isEvenNumber方法里面后，往下执行int number&#x3D;10，再往下执行if语句判断\n3.if语句执行完会，再往下执行没有发现任何代码，方法调用就结束了\n4.带参数方法的定义和调用4.1带参数方法的定义\n4.2带参数方法的调用\n4.3案例class MethodDemo &#123;\npublic static void main(String[] args) &#123;\n//变量值的调用\n    isONumber(10);\n//变量的调用\n    int number=10;\n    isONumber(number);\n&#125;\n    public static void isONumber(int number)&#123;\n        if(number%2==0)&#123;\n            System.out.print(true);\n        &#125;else&#123;\n            System.out.print(false);\n        &#125;\n    &#125;\n&#125;\n//运行结果为\ntrue\n4.4形参和实参\n5.带返回值方法的定义和调用5.1带返回值方法的定义\n5.2带返回值方法的调用\n5.3案例class MethodDemo &#123;\n    public static void main(String[] args) &#123;\n        //isONumber(10);\n        //true;没有意义，不输出true\n        boolean zhi=isONumber(10);\n        System.out.print(zhi);\n    &#125;\n    public static Boolean isONumber(int number)&#123;\n        if(number%2==0)&#123;\n           return true;\n        &#125;else&#123;\n            return false;\n        &#125;\n    &#125;\n&#125;\n6.方法的注意事项6.1方法不能嵌套定义\n6.2void表示无返回值可以省略return，也可以单独的书写return，后面不加数据\n  \n6.3方法的通用格式\n\n7.方法重载7.1方法重载概述1.方法重载指同一个类中定义的多个方法之间的关系，满足下列条件的多个方法相互构成重载\n注意：多个方法在同一个类中\n        多个方法具有**相同的方法名**\n\n   多个方法的参数不相同，类型不同或者数量不同\n7.2方法重载特点1.重载仅对应方法的定义，与方法的调用无关，通用方式参照标准格式\n2.重载仅针对同一个类中方法的名称与参数进行识别，与返回值无关，换句话说不能通过返回值来判定两个方法是否相互构成重载\n\n8.方法的参数传递8.1基本类型对于基本数据类型的参数，形式参数的改变，不影响实际参数的值\n\n8.2引用类型对于引用类型的参数，形式参数的改变，影响实际参数的值\n\n9.递归即在方法中调用方法\n","slug":"Java-2","date":"2022-11-26T03:00:00.000Z","categories_index":"分享","tags_index":"","author_index":"Humble"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new \"My New Post\"\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2022-11-25T11:55:34.263Z","categories_index":"分享","tags_index":"","author_index":"Humble"}]